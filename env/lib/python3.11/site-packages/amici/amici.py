"""

Core C++ bindings

This module encompasses the complete public C++ API of AMICI, which was
exposed via swig. All functions listed here are directly accessible in the
main amici package, i.e., :py:class:`amici.amici.ExpData` is available as
``amici.ExpData``.
Usage of functions and classes from the base ``amici`` package is
generally recommended as they often include convenience wrappers that avoid
common pitfalls when accessing C++ types from python and implement some
nonstandard type conversions.

"""
from __future__ import annotations
import sys
import os
if sys.platform == 'win32' and (dll_dirs := os.environ.get('AMICI_DLL_DIRS')):
    for dll_dir in dll_dirs.split(os.pathsep):
        os.add_dll_directory(dll_dir)
from typing import TYPE_CHECKING, Iterable, Union
from collections.abc import Sequence
import numpy as np
if TYPE_CHECKING:
    import numpy
from sys import version_info as _swig_python_version_info
if __package__ or '.' in __name__:
    from . import _amici
else:
    import _amici
try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = 'proxy of ' + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ''
    return '<%s.%s; %s >' % (self.__class__.__module__, self.__class__.__name__, strthis)

def _swig_setattr_nondynamic_instance_variable(set):

    def set_instance_attr(self, name, value):
        if name == 'this':
            set(self, name, value)
        elif name == 'thisown':
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError('You cannot add instance attributes to %s' % self)
    return set_instance_attr

def _swig_setattr_nondynamic_class_variable(set):

    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and (not isinstance(getattr(cls, name), property)):
            set(cls, name, value)
        else:
            raise AttributeError('You cannot add class attributes to %s' % cls)
    return set_class_attr

def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""

    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper

class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)

class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError('No constructor defined - class is abstract')
    __repr__ = _swig_repr
    __swig_destroy__ = _amici.delete_SwigPyIterator

    def value(self):
        return _amici.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _amici.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _amici.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _amici.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _amici.SwigPyIterator_equal(self, x)

    def copy(self):
        return _amici.SwigPyIterator_copy(self)

    def next(self):
        return _amici.SwigPyIterator_next(self)

    def __next__(self):
        return _amici.SwigPyIterator___next__(self)

    def previous(self):
        return _amici.SwigPyIterator_previous(self)

    def advance(self, n):
        return _amici.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _amici.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _amici.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _amici.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _amici.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _amici.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _amici.SwigPyIterator___sub__(self, *args)

    def __iter__(self):
        return self
_amici.SwigPyIterator_swigregister(SwigPyIterator)

class DoubleVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self):
        return _amici.DoubleVector_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _amici.DoubleVector___nonzero__(self)

    def __bool__(self):
        return _amici.DoubleVector___bool__(self)

    def __len__(self):
        return _amici.DoubleVector___len__(self)

    def __getslice__(self, i, j):
        return _amici.DoubleVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _amici.DoubleVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _amici.DoubleVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _amici.DoubleVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _amici.DoubleVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _amici.DoubleVector___setitem__(self, *args)

    def pop(self):
        return _amici.DoubleVector_pop(self)

    def append(self, x):
        return _amici.DoubleVector_append(self, x)

    def empty(self):
        return _amici.DoubleVector_empty(self)

    def size(self):
        return _amici.DoubleVector_size(self)

    def swap(self, v):
        return _amici.DoubleVector_swap(self, v)

    def begin(self):
        return _amici.DoubleVector_begin(self)

    def end(self):
        return _amici.DoubleVector_end(self)

    def rbegin(self):
        return _amici.DoubleVector_rbegin(self)

    def rend(self):
        return _amici.DoubleVector_rend(self)

    def clear(self):
        return _amici.DoubleVector_clear(self)

    def get_allocator(self):
        return _amici.DoubleVector_get_allocator(self)

    def pop_back(self):
        return _amici.DoubleVector_pop_back(self)

    def erase(self, *args):
        return _amici.DoubleVector_erase(self, *args)

    def __init__(self, *args):
        _amici.DoubleVector_swiginit(self, _amici.new_DoubleVector(*args))

    def push_back(self, x):
        return _amici.DoubleVector_push_back(self, x)

    def front(self):
        return _amici.DoubleVector_front(self)

    def back(self):
        return _amici.DoubleVector_back(self)

    def assign(self, n, x):
        return _amici.DoubleVector_assign(self, n, x)

    def resize(self, *args):
        return _amici.DoubleVector_resize(self, *args)

    def insert(self, *args):
        return _amici.DoubleVector_insert(self, *args)

    def reserve(self, n):
        return _amici.DoubleVector_reserve(self, n)

    def capacity(self):
        return _amici.DoubleVector_capacity(self)

    def __repr__(self):
        return self.this.__repr__()[:-1] + '; ' + repr(np.asarray(self, dtype=np.float64)) + ' >'
    __swig_destroy__ = _amici.delete_DoubleVector
_amici.DoubleVector_swigregister(DoubleVector)

class IntVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self):
        return _amici.IntVector_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _amici.IntVector___nonzero__(self)

    def __bool__(self):
        return _amici.IntVector___bool__(self)

    def __len__(self):
        return _amici.IntVector___len__(self)

    def __getslice__(self, i, j):
        return _amici.IntVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _amici.IntVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _amici.IntVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _amici.IntVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _amici.IntVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _amici.IntVector___setitem__(self, *args)

    def pop(self):
        return _amici.IntVector_pop(self)

    def append(self, x):
        return _amici.IntVector_append(self, x)

    def empty(self):
        return _amici.IntVector_empty(self)

    def size(self):
        return _amici.IntVector_size(self)

    def swap(self, v):
        return _amici.IntVector_swap(self, v)

    def begin(self):
        return _amici.IntVector_begin(self)

    def end(self):
        return _amici.IntVector_end(self)

    def rbegin(self):
        return _amici.IntVector_rbegin(self)

    def rend(self):
        return _amici.IntVector_rend(self)

    def clear(self):
        return _amici.IntVector_clear(self)

    def get_allocator(self):
        return _amici.IntVector_get_allocator(self)

    def pop_back(self):
        return _amici.IntVector_pop_back(self)

    def erase(self, *args):
        return _amici.IntVector_erase(self, *args)

    def __init__(self, *args):
        _amici.IntVector_swiginit(self, _amici.new_IntVector(*args))

    def push_back(self, x):
        return _amici.IntVector_push_back(self, x)

    def front(self):
        return _amici.IntVector_front(self)

    def back(self):
        return _amici.IntVector_back(self)

    def assign(self, n, x):
        return _amici.IntVector_assign(self, n, x)

    def resize(self, *args):
        return _amici.IntVector_resize(self, *args)

    def insert(self, *args):
        return _amici.IntVector_insert(self, *args)

    def reserve(self, n):
        return _amici.IntVector_reserve(self, n)

    def capacity(self):
        return _amici.IntVector_capacity(self)

    def __repr__(self):
        return self.this.__repr__()[:-1] + '; ' + repr(np.asarray(self, dtype=np.int64)) + ' >'
    __swig_destroy__ = _amici.delete_IntVector
_amici.IntVector_swigregister(IntVector)

class BoolVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self):
        return _amici.BoolVector_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _amici.BoolVector___nonzero__(self)

    def __bool__(self):
        return _amici.BoolVector___bool__(self)

    def __len__(self):
        return _amici.BoolVector___len__(self)

    def __getslice__(self, i, j):
        return _amici.BoolVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _amici.BoolVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _amici.BoolVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _amici.BoolVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _amici.BoolVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _amici.BoolVector___setitem__(self, *args)

    def pop(self):
        return _amici.BoolVector_pop(self)

    def append(self, x):
        return _amici.BoolVector_append(self, x)

    def empty(self):
        return _amici.BoolVector_empty(self)

    def size(self):
        return _amici.BoolVector_size(self)

    def swap(self, v):
        return _amici.BoolVector_swap(self, v)

    def begin(self):
        return _amici.BoolVector_begin(self)

    def end(self):
        return _amici.BoolVector_end(self)

    def rbegin(self):
        return _amici.BoolVector_rbegin(self)

    def rend(self):
        return _amici.BoolVector_rend(self)

    def clear(self):
        return _amici.BoolVector_clear(self)

    def get_allocator(self):
        return _amici.BoolVector_get_allocator(self)

    def pop_back(self):
        return _amici.BoolVector_pop_back(self)

    def erase(self, *args):
        return _amici.BoolVector_erase(self, *args)

    def __init__(self, *args):
        _amici.BoolVector_swiginit(self, _amici.new_BoolVector(*args))

    def push_back(self, x):
        return _amici.BoolVector_push_back(self, x)

    def front(self):
        return _amici.BoolVector_front(self)

    def back(self):
        return _amici.BoolVector_back(self)

    def assign(self, n, x):
        return _amici.BoolVector_assign(self, n, x)

    def resize(self, *args):
        return _amici.BoolVector_resize(self, *args)

    def insert(self, *args):
        return _amici.BoolVector_insert(self, *args)

    def reserve(self, n):
        return _amici.BoolVector_reserve(self, n)

    def capacity(self):
        return _amici.BoolVector_capacity(self)

    def __repr__(self):
        return self.this.__repr__()[:-1] + '; ' + repr(np.asarray(self, dtype=np.bool_)) + ' >'
    __swig_destroy__ = _amici.delete_BoolVector
_amici.BoolVector_swigregister(BoolVector)

class StringVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self):
        return _amici.StringVector_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _amici.StringVector___nonzero__(self)

    def __bool__(self):
        return _amici.StringVector___bool__(self)

    def __len__(self):
        return _amici.StringVector___len__(self)

    def __getslice__(self, i, j):
        return _amici.StringVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _amici.StringVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _amici.StringVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _amici.StringVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _amici.StringVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _amici.StringVector___setitem__(self, *args)

    def pop(self):
        return _amici.StringVector_pop(self)

    def append(self, x):
        return _amici.StringVector_append(self, x)

    def empty(self):
        return _amici.StringVector_empty(self)

    def size(self):
        return _amici.StringVector_size(self)

    def swap(self, v):
        return _amici.StringVector_swap(self, v)

    def begin(self):
        return _amici.StringVector_begin(self)

    def end(self):
        return _amici.StringVector_end(self)

    def rbegin(self):
        return _amici.StringVector_rbegin(self)

    def rend(self):
        return _amici.StringVector_rend(self)

    def clear(self):
        return _amici.StringVector_clear(self)

    def get_allocator(self):
        return _amici.StringVector_get_allocator(self)

    def pop_back(self):
        return _amici.StringVector_pop_back(self)

    def erase(self, *args):
        return _amici.StringVector_erase(self, *args)

    def __init__(self, *args):
        _amici.StringVector_swiginit(self, _amici.new_StringVector(*args))

    def push_back(self, x):
        return _amici.StringVector_push_back(self, x)

    def front(self):
        return _amici.StringVector_front(self)

    def back(self):
        return _amici.StringVector_back(self)

    def assign(self, n, x):
        return _amici.StringVector_assign(self, n, x)

    def resize(self, *args):
        return _amici.StringVector_resize(self, *args)

    def insert(self, *args):
        return _amici.StringVector_insert(self, *args)

    def reserve(self, n):
        return _amici.StringVector_reserve(self, n)

    def capacity(self):
        return _amici.StringVector_capacity(self)
    __swig_destroy__ = _amici.delete_StringVector
_amici.StringVector_swigregister(StringVector)

class StringDoubleMap(object):
    """
    Swig-Generated class templating :class:`Dict`
    [:class:`str`, :class:`float`] to facilitate interfacing with C++ bindings.
    """
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self):
        return _amici.StringDoubleMap_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _amici.StringDoubleMap___nonzero__(self)

    def __bool__(self):
        return _amici.StringDoubleMap___bool__(self)

    def __len__(self):
        return _amici.StringDoubleMap___len__(self)

    def __iter__(self):
        return self.key_iterator()

    def iterkeys(self):
        return self.key_iterator()

    def itervalues(self):
        return self.value_iterator()

    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key):
        return _amici.StringDoubleMap___getitem__(self, key)

    def __delitem__(self, key):
        return _amici.StringDoubleMap___delitem__(self, key)

    def has_key(self, key):
        return _amici.StringDoubleMap_has_key(self, key)

    def keys(self):
        return _amici.StringDoubleMap_keys(self)

    def values(self):
        return _amici.StringDoubleMap_values(self)

    def items(self):
        return _amici.StringDoubleMap_items(self)

    def __contains__(self, key):
        return _amici.StringDoubleMap___contains__(self, key)

    def key_iterator(self):
        return _amici.StringDoubleMap_key_iterator(self)

    def value_iterator(self):
        return _amici.StringDoubleMap_value_iterator(self)

    def __setitem__(self, *args):
        return _amici.StringDoubleMap___setitem__(self, *args)

    def asdict(self):
        return _amici.StringDoubleMap_asdict(self)

    def __init__(self, *args):
        _amici.StringDoubleMap_swiginit(self, _amici.new_StringDoubleMap(*args))

    def empty(self):
        return _amici.StringDoubleMap_empty(self)

    def size(self):
        return _amici.StringDoubleMap_size(self)

    def swap(self, v):
        return _amici.StringDoubleMap_swap(self, v)

    def begin(self):
        return _amici.StringDoubleMap_begin(self)

    def end(self):
        return _amici.StringDoubleMap_end(self)

    def rbegin(self):
        return _amici.StringDoubleMap_rbegin(self)

    def rend(self):
        return _amici.StringDoubleMap_rend(self)

    def clear(self):
        return _amici.StringDoubleMap_clear(self)

    def get_allocator(self):
        return _amici.StringDoubleMap_get_allocator(self)

    def count(self, x):
        return _amici.StringDoubleMap_count(self, x)

    def erase(self, *args):
        return _amici.StringDoubleMap_erase(self, *args)

    def find(self, x):
        return _amici.StringDoubleMap_find(self, x)

    def lower_bound(self, x):
        return _amici.StringDoubleMap_lower_bound(self, x)

    def upper_bound(self, x):
        return _amici.StringDoubleMap_upper_bound(self, x)

    def __repr__(self):
        return self.this.__repr__()[:-1] + '; ' + repr(dict(self)) + ' >'
    __swig_destroy__ = _amici.delete_StringDoubleMap
_amici.StringDoubleMap_swigregister(StringDoubleMap)

def stdVec2ndarray(*args):
    """
    *Overload 1:*

    Convert 1D array to *non-owning* numpy ndarray.
    :type vec: DoubleVector
    :param vec:
    :type dim1: int
    :param dim1:
    :rtype: PyObject
    :return: 

    |

    *Overload 2:*

    Convert row-major flattened 2D array to *non-owning* numpy ndarray.
    :type vec: DoubleVector
    :param vec:
    :type dim1: int
    :param dim1:
    :type dim2: int
    :param dim2:
    :rtype: PyObject
    :return: 

    |

    *Overload 3:*

    Convert row-major flattened 3D array to *non-owning* numpy ndarray.
    :type vec: DoubleVector
    :param vec:
    :type dim1: int
    :param dim1:
    :type dim2: int
    :param dim2:
    :type dim3: int
    :param dim3:
    :rtype: PyObject
    :return: 

    |

    *Overload 4:*

    Convert row-major flattened 2D array to *non-owning* numpy ndarray.
    :type vec: DoubleVector
    :param vec:
    :type dim1: int
    :param dim1:
    :type dim2: int
    :param dim2:
    :type dim3: int
    :param dim3:
    :type dim4: int
    :param dim4:
    :rtype: PyObject
    :return: 

    |

    *Overload 5:*

    Convert 1D array to *non-owning* numpy ndarray.
    :type vec: IntVector
    :param vec:
    :type dim1: int
    :param dim1:
    :rtype: PyObject
    :return: 

    |

    *Overload 6:*

    Convert row-major flattened 2D array to *non-owning* numpy ndarray.
    :type vec: IntVector
    :param vec:
    :type dim1: int
    :param dim1:
    :type dim2: int
    :param dim2:
    :rtype: PyObject
    :return: 

    |

    *Overload 7:*

    Convert row-major flattened 3D array to *non-owning* numpy ndarray.
    :type vec: IntVector
    :param vec:
    :type dim1: int
    :param dim1:
    :type dim2: int
    :param dim2:
    :type dim3: int
    :param dim3:
    :rtype: PyObject
    :return: 

    |

    *Overload 8:*

    Convert row-major flattened 2D array to *non-owning* numpy ndarray.
    :type vec: IntVector
    :param vec:
    :type dim1: int
    :param dim1:
    :type dim2: int
    :param dim2:
    :type dim3: int
    :param dim3:
    :type dim4: int
    :param dim4:
    :rtype: PyObject
    :return: 
    """
    return _amici.stdVec2ndarray(*args)

class SolverPtr(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _amici.SolverPtr_swiginit(self, _amici.new_SolverPtr(*args))

    def __deref__(self):
        return _amici.SolverPtr___deref__(self)

    def release(self):
        return _amici.SolverPtr_release(self)

    def reset(self, *args):
        return _amici.SolverPtr_reset(self, *args)

    def swap(self, __u):
        return _amici.SolverPtr_swap(self, __u)

    def get(self):
        return _amici.SolverPtr_get(self)

    def __nonzero__(self):
        return _amici.SolverPtr___nonzero__(self)
    __bool__ = __nonzero__
    __swig_destroy__ = _amici.delete_SolverPtr

    def __repr__(self):
        return _solver_repr(self)

    def __deepcopy__(self, memo):
        return self.clone()

    def clone(self) -> 'Solver':
        """
        Clone this instance
        :return: The clone
        """
        return _amici.SolverPtr_clone(self)

    def getSensitivityMethod(self) -> 'SensitivityMethod':
        """
        Return current sensitivity method
        :return: method enum
        """
        return _amici.SolverPtr_getSensitivityMethod(self)

    def setSensitivityMethod(self, sensi_meth: 'SensitivityMethod'):
        """
        Set sensitivity method
        :param sensi_meth:
        """
        return _amici.SolverPtr_setSensitivityMethod(self, sensi_meth)

    def getSensitivityMethodPreequilibration(self) -> 'SensitivityMethod':
        """
        Return current sensitivity method during preequilibration
        :return: method enum
        """
        return _amici.SolverPtr_getSensitivityMethodPreequilibration(self)

    def setSensitivityMethodPreequilibration(self, sensi_meth_preeq: 'SensitivityMethod'):
        """
        Set sensitivity method for preequilibration
        :param sensi_meth_preeq:
        """
        return _amici.SolverPtr_setSensitivityMethodPreequilibration(self, sensi_meth_preeq)

    def getNewtonMaxSteps(self) -> int:
        """
        Get maximum number of allowed Newton steps for steady state
        computation
        :return: 
        """
        return _amici.SolverPtr_getNewtonMaxSteps(self)

    def setNewtonMaxSteps(self, newton_maxsteps: int):
        """
        Set maximum number of allowed Newton steps for steady state
        computation
        :param newton_maxsteps:
        """
        return _amici.SolverPtr_setNewtonMaxSteps(self, newton_maxsteps)

    def getNewtonDampingFactorMode(self) -> 'NewtonDampingFactorMode':
        """
        Get a state of the damping factor used in the Newton solver
        :return: 
        """
        return _amici.SolverPtr_getNewtonDampingFactorMode(self)

    def setNewtonDampingFactorMode(self, dampingFactorMode: 'NewtonDampingFactorMode'):
        """
        Turn on/off a damping factor in the Newton method
        :param dampingFactorMode:
        """
        return _amici.SolverPtr_setNewtonDampingFactorMode(self, dampingFactorMode)

    def getNewtonDampingFactorLowerBound(self) -> 'float':
        """
        Get a lower bound of the damping factor used in the Newton solver
        :return: 
        """
        return _amici.SolverPtr_getNewtonDampingFactorLowerBound(self)

    def setNewtonDampingFactorLowerBound(self, dampingFactorLowerBound: 'float'):
        """
        Set a lower bound of the damping factor in the Newton solver
        :param dampingFactorLowerBound:
        """
        return _amici.SolverPtr_setNewtonDampingFactorLowerBound(self, dampingFactorLowerBound)

    def getSensitivityOrder(self) -> 'SensitivityOrder':
        """
        Get sensitivity order
        :return: sensitivity order
        """
        return _amici.SolverPtr_getSensitivityOrder(self)

    def setSensitivityOrder(self, sensi: 'SensitivityOrder'):
        """
        Set the sensitivity order
        :param sensi: sensitivity order
        """
        return _amici.SolverPtr_setSensitivityOrder(self, sensi)

    def getRelativeTolerance(self) -> 'float':
        """
        Get the relative tolerances for the forward problem

        Same tolerance is used for the backward problem if not specified
        differently via setRelativeToleranceASA.

        :return: relative tolerances
        """
        return _amici.SolverPtr_getRelativeTolerance(self)

    def setRelativeTolerance(self, rtol: 'float'):
        """
        Sets the relative tolerances for the forward problem

        Same tolerance is used for the backward problem if not specified
        differently via setRelativeToleranceASA.

        :param rtol: relative tolerance (non-negative number)
        """
        return _amici.SolverPtr_setRelativeTolerance(self, rtol)

    def getAbsoluteTolerance(self) -> 'float':
        """
        Get the absolute tolerances for the forward problem

        Same tolerance is used for the backward problem if not specified
        differently via setAbsoluteToleranceASA.

        :return: absolute tolerances
        """
        return _amici.SolverPtr_getAbsoluteTolerance(self)

    def setAbsoluteTolerance(self, atol: 'float'):
        """
        Sets the absolute tolerances for the forward problem

        Same tolerance is used for the backward problem if not specified
        differently via setAbsoluteToleranceASA.

        :param atol: absolute tolerance (non-negative number)
        """
        return _amici.SolverPtr_setAbsoluteTolerance(self, atol)

    def getRelativeToleranceFSA(self) -> 'float':
        """
        Returns the relative tolerances for the forward sensitivity
        problem
        :return: relative tolerances
        """
        return _amici.SolverPtr_getRelativeToleranceFSA(self)

    def setRelativeToleranceFSA(self, rtol: 'float'):
        """
        Sets the relative tolerances for the forward sensitivity problem
        :param rtol: relative tolerance (non-negative number)
        """
        return _amici.SolverPtr_setRelativeToleranceFSA(self, rtol)

    def getAbsoluteToleranceFSA(self) -> 'float':
        """
        Returns the absolute tolerances for the forward sensitivity
        problem
        :return: absolute tolerances
        """
        return _amici.SolverPtr_getAbsoluteToleranceFSA(self)

    def setAbsoluteToleranceFSA(self, atol: 'float'):
        """
        Sets the absolute tolerances for the forward sensitivity problem
        :param atol: absolute tolerance (non-negative number)
        """
        return _amici.SolverPtr_setAbsoluteToleranceFSA(self, atol)

    def getRelativeToleranceB(self) -> 'float':
        """
        Returns the relative tolerances for the adjoint sensitivity
        problem
        :return: relative tolerances
        """
        return _amici.SolverPtr_getRelativeToleranceB(self)

    def setRelativeToleranceB(self, rtol: 'float'):
        """
        Sets the relative tolerances for the adjoint sensitivity problem
        :param rtol: relative tolerance (non-negative number)
        """
        return _amici.SolverPtr_setRelativeToleranceB(self, rtol)

    def getAbsoluteToleranceB(self) -> 'float':
        """
        Returns the absolute tolerances for the backward problem for
        adjoint sensitivity analysis
        :return: absolute tolerances
        """
        return _amici.SolverPtr_getAbsoluteToleranceB(self)

    def setAbsoluteToleranceB(self, atol: 'float'):
        """
        Sets the absolute tolerances for the backward problem for
        adjoint sensitivity analysis
        :param atol: absolute tolerance (non-negative number)
        """
        return _amici.SolverPtr_setAbsoluteToleranceB(self, atol)

    def getRelativeToleranceQuadratures(self) -> 'float':
        """
        Returns the relative tolerance for the quadrature problem
        :return: relative tolerance
        """
        return _amici.SolverPtr_getRelativeToleranceQuadratures(self)

    def setRelativeToleranceQuadratures(self, rtol: 'float'):
        """
        sets the relative tolerance for the quadrature problem
        :param rtol: relative tolerance (non-negative number)
        """
        return _amici.SolverPtr_setRelativeToleranceQuadratures(self, rtol)

    def getAbsoluteToleranceQuadratures(self) -> 'float':
        """
        returns the absolute tolerance for the quadrature problem
        :return: absolute tolerance
        """
        return _amici.SolverPtr_getAbsoluteToleranceQuadratures(self)

    def setAbsoluteToleranceQuadratures(self, atol: 'float'):
        """
        sets the absolute tolerance for the quadrature problem
        :param atol: absolute tolerance (non-negative number)
        """
        return _amici.SolverPtr_setAbsoluteToleranceQuadratures(self, atol)

    def getSteadyStateToleranceFactor(self) -> 'float':
        """
        returns the steady state simulation tolerance factor.

        Steady state simulation tolerances are the product of the simulation
        tolerances and this factor, unless manually set with
        `set(Absolute/Relative)ToleranceSteadyState()`.
        :return: steady state simulation tolerance factor
        """
        return _amici.SolverPtr_getSteadyStateToleranceFactor(self)

    def setSteadyStateToleranceFactor(self, factor: 'float'):
        """
        set the steady state simulation tolerance factor.

        Steady state simulation tolerances are the product of the simulation
        tolerances and this factor, unless manually set with
        `set(Absolute/Relative)ToleranceSteadyState()`.
        :param factor: tolerance factor (non-negative number)
        """
        return _amici.SolverPtr_setSteadyStateToleranceFactor(self, factor)

    def getRelativeToleranceSteadyState(self) -> 'float':
        """
        returns the relative tolerance for the steady state problem
        :return: relative tolerance
        """
        return _amici.SolverPtr_getRelativeToleranceSteadyState(self)

    def setRelativeToleranceSteadyState(self, rtol: 'float'):
        """
        sets the relative tolerance for the steady state problem
        :param rtol: relative tolerance (non-negative number)
        """
        return _amici.SolverPtr_setRelativeToleranceSteadyState(self, rtol)

    def getAbsoluteToleranceSteadyState(self) -> 'float':
        """
        returns the absolute tolerance for the steady state problem
        :return: absolute tolerance
        """
        return _amici.SolverPtr_getAbsoluteToleranceSteadyState(self)

    def setAbsoluteToleranceSteadyState(self, atol: 'float'):
        """
        sets the absolute tolerance for the steady state problem
        :param atol: absolute tolerance (non-negative number)
        """
        return _amici.SolverPtr_setAbsoluteToleranceSteadyState(self, atol)

    def getSteadyStateSensiToleranceFactor(self) -> 'float':
        """
        returns the steady state sensitivity simulation tolerance factor.

        Steady state sensitivity simulation tolerances are the product of the
        sensitivity simulation tolerances and this factor, unless manually set
        with `set(Absolute/Relative)ToleranceSteadyStateSensi()`.
        :return: steady state simulation tolerance factor
        """
        return _amici.SolverPtr_getSteadyStateSensiToleranceFactor(self)

    def setSteadyStateSensiToleranceFactor(self, factor: 'float'):
        """
        set the steady state sensitivity simulation tolerance factor.

        Steady state sensitivity simulation tolerances are the product of the
        sensitivity simulation tolerances and this factor, unless manually set
        with `set(Absolute/Relative)ToleranceSteadyStateSensi()`.
        :param factor: tolerance factor (non-negative number)
        """
        return _amici.SolverPtr_setSteadyStateSensiToleranceFactor(self, factor)

    def getRelativeToleranceSteadyStateSensi(self) -> 'float':
        """
        returns the relative tolerance for the sensitivities of the
        steady state problem
        :return: relative tolerance
        """
        return _amici.SolverPtr_getRelativeToleranceSteadyStateSensi(self)

    def setRelativeToleranceSteadyStateSensi(self, rtol: 'float'):
        """
        sets the relative tolerance for the sensitivities of the
        steady state problem
        :param rtol: relative tolerance (non-negative number)
        """
        return _amici.SolverPtr_setRelativeToleranceSteadyStateSensi(self, rtol)

    def getAbsoluteToleranceSteadyStateSensi(self) -> 'float':
        """
        returns the absolute tolerance for the sensitivities of the
        steady state problem
        :return: absolute tolerance
        """
        return _amici.SolverPtr_getAbsoluteToleranceSteadyStateSensi(self)

    def setAbsoluteToleranceSteadyStateSensi(self, atol: 'float'):
        """
        sets the absolute tolerance for the sensitivities of the
        steady state problem
        :param atol: absolute tolerance (non-negative number)
        """
        return _amici.SolverPtr_setAbsoluteToleranceSteadyStateSensi(self, atol)

    def getMaxSteps(self) -> int:
        """
        returns the maximum number of solver steps for the forward
        problem
        :return: maximum number of solver steps
        """
        return _amici.SolverPtr_getMaxSteps(self)

    def setMaxSteps(self, maxsteps: int):
        """
        sets the maximum number of solver steps for the forward problem
        :param maxsteps: maximum number of solver steps (positive number)
        """
        return _amici.SolverPtr_setMaxSteps(self, maxsteps)

    def getMaxTime(self) -> 'float':
        """
        Returns the maximum time allowed for integration
        :return: Time in seconds
        """
        return _amici.SolverPtr_getMaxTime(self)

    def setMaxTime(self, maxtime: 'float'):
        """
        Set the maximum CPU time allowed for integration
        :param maxtime: Time in seconds. Zero means infinite time.
        """
        return _amici.SolverPtr_setMaxTime(self, maxtime)

    def getMaxStepsBackwardProblem(self) -> int:
        """
        returns the maximum number of solver steps for the backward
        problem
        :return: maximum number of solver steps
        """
        return _amici.SolverPtr_getMaxStepsBackwardProblem(self)

    def setMaxStepsBackwardProblem(self, maxsteps: int):
        """
        sets the maximum number of solver steps for the backward problem

        :param maxsteps: maximum number of solver steps (non-negative number)

        Notes: default behaviour (100 times the value for the forward problem) can
        be restored by passing maxsteps=0
        """
        return _amici.SolverPtr_setMaxStepsBackwardProblem(self, maxsteps)

    def getLinearMultistepMethod(self) -> 'LinearMultistepMethod':
        """
        returns the linear system multistep method
        :return: linear system multistep method
        """
        return _amici.SolverPtr_getLinearMultistepMethod(self)

    def setLinearMultistepMethod(self, lmm: 'LinearMultistepMethod'):
        """
        sets the linear system multistep method
        :param lmm: linear system multistep method
        """
        return _amici.SolverPtr_setLinearMultistepMethod(self, lmm)

    def getNonlinearSolverIteration(self) -> 'NonlinearSolverIteration':
        """
        returns the nonlinear system solution method
        :return: 
        """
        return _amici.SolverPtr_getNonlinearSolverIteration(self)

    def setNonlinearSolverIteration(self, iter: 'NonlinearSolverIteration'):
        """
        sets the nonlinear system solution method
        :param iter: nonlinear system solution method
        """
        return _amici.SolverPtr_setNonlinearSolverIteration(self, iter)

    def getInterpolationType(self) -> 'InterpolationType':
        """
        getInterpolationType
        :return: 
        """
        return _amici.SolverPtr_getInterpolationType(self)

    def setInterpolationType(self, interpType: 'InterpolationType'):
        """
        sets the interpolation of the forward solution that is used for
        the backwards problem
        :param interpType: interpolation type
        """
        return _amici.SolverPtr_setInterpolationType(self, interpType)

    def getStateOrdering(self) -> int:
        """
        Gets KLU / SuperLUMT state ordering mode

        :return: State-ordering as integer according to
            SUNLinSolKLU::StateOrdering or SUNLinSolSuperLUMT::StateOrdering (which
            differ).
        """
        return _amici.SolverPtr_getStateOrdering(self)

    def setStateOrdering(self, ordering: int):
        """
        Sets KLU / SuperLUMT state ordering mode

        This only applies when linsol is set to LinearSolver::KLU or
        LinearSolver::SuperLUMT. Mind the difference between
        SUNLinSolKLU::StateOrdering and SUNLinSolSuperLUMT::StateOrdering.
        :param ordering: state ordering
        """
        return _amici.SolverPtr_setStateOrdering(self, ordering)

    def getStabilityLimitFlag(self) -> bool:
        """
        returns stability limit detection mode
        :return: stldet can be false (deactivated) or true (activated)
        """
        return _amici.SolverPtr_getStabilityLimitFlag(self)

    def setStabilityLimitFlag(self, stldet: bool):
        """
        set stability limit detection mode
        :param stldet: can be false (deactivated) or true (activated)
        """
        return _amici.SolverPtr_setStabilityLimitFlag(self, stldet)

    def getLinearSolver(self) -> 'LinearSolver':
        """
        getLinearSolver
        :return: 
        """
        return _amici.SolverPtr_getLinearSolver(self)

    def setLinearSolver(self, linsol: 'LinearSolver'):
        """
        setLinearSolver
        :param linsol:
        """
        return _amici.SolverPtr_setLinearSolver(self, linsol)

    def getInternalSensitivityMethod(self) -> 'InternalSensitivityMethod':
        """
        returns the internal sensitivity method
        :return: internal sensitivity method
        """
        return _amici.SolverPtr_getInternalSensitivityMethod(self)

    def setInternalSensitivityMethod(self, ism: 'InternalSensitivityMethod'):
        """
        sets the internal sensitivity method
        :param ism: internal sensitivity method
        """
        return _amici.SolverPtr_setInternalSensitivityMethod(self, ism)

    def getReturnDataReportingMode(self) -> 'RDataReporting':
        """
        returns the ReturnData reporting mode
        :return: ReturnData reporting mode
        """
        return _amici.SolverPtr_getReturnDataReportingMode(self)

    def setReturnDataReportingMode(self, rdrm: 'RDataReporting'):
        """
        sets the ReturnData reporting mode
        :param rdrm: ReturnData reporting mode
        """
        return _amici.SolverPtr_setReturnDataReportingMode(self, rdrm)

    def nx(self) -> int:
        """
        number of states with which the solver was initialized
        :return: x.getLength()
        """
        return _amici.SolverPtr_nx(self)

    def nplist(self) -> int:
        """
        number of parameters with which the solver was initialized
        :return: sx.getLength()
        """
        return _amici.SolverPtr_nplist(self)

    def nquad(self) -> int:
        """
        number of quadratures with which the solver was initialized
        :return: xQB.getLength()
        """
        return _amici.SolverPtr_nquad(self)

    def computingFSA(self) -> bool:
        """
        check if FSA is being computed
        :return: flag
        """
        return _amici.SolverPtr_computingFSA(self)

    def computingASA(self) -> bool:
        """
        check if ASA is being computed
        :return: flag
        """
        return _amici.SolverPtr_computingASA(self)

    def getNewtonStepSteadyStateCheck(self) -> bool:
        """
        Returns how convergence checks for steadystate computation are
        performed. If activated, convergence checks are limited to every 25 steps
        in the simulation solver to limit performance impact.
        :return: boolean flag indicating newton step (true) or the right hand side
            (false)
        """
        return _amici.SolverPtr_getNewtonStepSteadyStateCheck(self)

    def getSensiSteadyStateCheck(self) -> bool:
        """
        Returns how convergence checks for steadystate computation are
        performed.
        :return: boolean flag indicating state and sensitivity equations (true) or
            only state variables (false).
        """
        return _amici.SolverPtr_getSensiSteadyStateCheck(self)

    def setNewtonStepSteadyStateCheck(self, flag: bool):
        """
        Sets how convergence checks for steadystate computation are
        performed.
        :param flag: boolean flag to pick newton step (true) or the right hand
            side (false, default)
        """
        return _amici.SolverPtr_setNewtonStepSteadyStateCheck(self, flag)

    def setSensiSteadyStateCheck(self, flag: bool):
        """
        Sets for which variables convergence checks for steadystate
        computation are performed.
        :param flag: boolean flag to pick state and sensitivity equations (true,
            default) or only state variables (false).
        """
        return _amici.SolverPtr_setSensiSteadyStateCheck(self, flag)

    def setMaxNonlinIters(self, max_nonlin_iters: int):
        """
        Set the maximum number of nonlinear solver iterations permitted
        per step.
        :param max_nonlin_iters: maximum number of nonlinear solver iterations
        """
        return _amici.SolverPtr_setMaxNonlinIters(self, max_nonlin_iters)

    def getMaxNonlinIters(self) -> int:
        """
        Get the maximum number of nonlinear solver iterations permitted
        per step.
        :return: maximum number of nonlinear solver iterations
        """
        return _amici.SolverPtr_getMaxNonlinIters(self)

    def setMaxConvFails(self, max_conv_fails: int):
        """
        Set the maximum number of nonlinear solver convergence failures
        permitted per step.
        :param max_conv_fails: maximum number of nonlinear solver convergence
        """
        return _amici.SolverPtr_setMaxConvFails(self, max_conv_fails)

    def getMaxConvFails(self) -> int:
        """
        Get the maximum number of nonlinear solver convergence failures
        permitted per step.
        :return: maximum number of nonlinear solver convergence
        """
        return _amici.SolverPtr_getMaxConvFails(self)

    def setConstraints(self, constraints: Sequence[float]):
        """
        Set constraints on the model state.

        See
        https://sundials.readthedocs.io/en/latest/cvode/Usage/index.html#c.CVodeSetConstraints.

        :param constraints:
        """
        return _amici.SolverPtr_setConstraints(self, constraints)

    def getConstraints(self) -> Sequence[float]:
        """
        Get constraints on the model state.
        :return: constraints
        """
        return _amici.SolverPtr_getConstraints(self)

    def setMaxStepSize(self, max_step_size: 'float'):
        """
        Set the maximum step size
        :param max_step_size: maximum step size. `0.0` means no limit.
        """
        return _amici.SolverPtr_setMaxStepSize(self, max_step_size)

    def getMaxStepSize(self) -> 'float':
        """
        Get the maximum step size
        :return: maximum step size
        """
        return _amici.SolverPtr_getMaxStepSize(self)
    logger = property(_amici.SolverPtr_logger_get, _amici.SolverPtr_logger_set, doc=' logger')
_amici.SolverPtr_swigregister(SolverPtr)

class ReturnDataPtr(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _amici.ReturnDataPtr_swiginit(self, _amici.new_ReturnDataPtr(*args))

    def __deref__(self):
        return _amici.ReturnDataPtr___deref__(self)

    def release(self):
        return _amici.ReturnDataPtr_release(self)

    def reset(self, *args):
        return _amici.ReturnDataPtr_reset(self, *args)

    def swap(self, __u):
        return _amici.ReturnDataPtr_swap(self, __u)

    def get(self):
        return _amici.ReturnDataPtr_get(self)

    def __nonzero__(self):
        return _amici.ReturnDataPtr___nonzero__(self)
    __bool__ = __nonzero__
    __swig_destroy__ = _amici.delete_ReturnDataPtr
    id = property(_amici.ReturnDataPtr_id_get, _amici.ReturnDataPtr_id_set, doc='Arbitrary (not necessarily unique) identifier.')
    ts = property(_amici.ReturnDataPtr_ts_get, _amici.ReturnDataPtr_ts_set, doc='timepoints (shape `nt`)')
    xdot = property(_amici.ReturnDataPtr_xdot_get, _amici.ReturnDataPtr_xdot_set, doc=' time derivative (shape `nx`) evaluated at `t_last`.')
    J = property(_amici.ReturnDataPtr_J_get, _amici.ReturnDataPtr_J_set, doc='\n    Jacobian of differential equation right hand side (shape `nx` x `nx`,\n    row-major) evaluated at `t_last`.\n    ')
    w = property(_amici.ReturnDataPtr_w_get, _amici.ReturnDataPtr_w_set, doc='\n    w data from the model (recurring terms in xdot, for imported SBML models\n    from python, this contains the flux vector) (shape `nt` x `nw`, row\n    major)\n    ')
    z = property(_amici.ReturnDataPtr_z_get, _amici.ReturnDataPtr_z_set, doc=' event output (shape `nmaxevent` x `nz`, row-major)')
    sigmaz = property(_amici.ReturnDataPtr_sigmaz_get, _amici.ReturnDataPtr_sigmaz_set, doc='\n    event output sigma standard deviation (shape `nmaxevent` x `nz`,\n    row-major)\n    ')
    sz = property(_amici.ReturnDataPtr_sz_get, _amici.ReturnDataPtr_sz_set, doc='\n    parameter derivative of event output\n    (shape `nmaxevent` x `nplist` x `nz`, row-major)\n    ')
    ssigmaz = property(_amici.ReturnDataPtr_ssigmaz_get, _amici.ReturnDataPtr_ssigmaz_set, doc='\n    parameter derivative of event output standard deviation\n    (shape `nmaxevent` x `nplist` x `nz`, row-major)\n    ')
    rz = property(_amici.ReturnDataPtr_rz_get, _amici.ReturnDataPtr_rz_set, doc=' event trigger output (shape `nmaxevent` x `nz`, row-major)')
    srz = property(_amici.ReturnDataPtr_srz_get, _amici.ReturnDataPtr_srz_set, doc='\n    parameter derivative of event trigger output\n    (shape `nmaxevent` x `nplist` x `nz`, row-major)\n    ')
    s2rz = property(_amici.ReturnDataPtr_s2rz_get, _amici.ReturnDataPtr_s2rz_set, doc='\n    second-order parameter derivative of event trigger output (shape\n    `nmaxevent` x `nztrue` x `nplist` x `nplist`, row-major)\n    ')
    x = property(_amici.ReturnDataPtr_x_get, _amici.ReturnDataPtr_x_set, doc=' state (shape `nt` x `nx`, row-major)')
    sx = property(_amici.ReturnDataPtr_sx_get, _amici.ReturnDataPtr_sx_set, doc='parameter derivative of state (shape `nt` x `nplist` x `nx`, row-major)')
    y = property(_amici.ReturnDataPtr_y_get, _amici.ReturnDataPtr_y_set, doc=' observable (shape `nt` x `ny`, row-major)')
    sigmay = property(_amici.ReturnDataPtr_sigmay_get, _amici.ReturnDataPtr_sigmay_set, doc=' observable standard deviation (shape `nt` x `ny`, row-major)')
    sy = property(_amici.ReturnDataPtr_sy_get, _amici.ReturnDataPtr_sy_set, doc='\n    parameter derivative of observable (shape `nt` x `nplist` x `ny`,\n    row-major)\n    ')
    ssigmay = property(_amici.ReturnDataPtr_ssigmay_get, _amici.ReturnDataPtr_ssigmay_set, doc='\n    parameter derivative of observable standard deviation\n    (shape `nt` x `nplist` x `ny`, row-major)\n    ')
    res = property(_amici.ReturnDataPtr_res_get, _amici.ReturnDataPtr_res_set, doc=' observable (shape `nt*ny`, row-major)')
    sres = property(_amici.ReturnDataPtr_sres_get, _amici.ReturnDataPtr_sres_set, doc='parameter derivative of residual (shape `nt*ny` x `nplist`, row-major)')
    FIM = property(_amici.ReturnDataPtr_FIM_get, _amici.ReturnDataPtr_FIM_set, doc=' fisher information matrix (shape `nplist` x `nplist`, row-major)')
    numsteps = property(_amici.ReturnDataPtr_numsteps_get, _amici.ReturnDataPtr_numsteps_set, doc=' number of integration steps forward problem (shape `nt`)')
    numstepsB = property(_amici.ReturnDataPtr_numstepsB_get, _amici.ReturnDataPtr_numstepsB_set, doc=' number of integration steps backward problem (shape `nt`)')
    numrhsevals = property(_amici.ReturnDataPtr_numrhsevals_get, _amici.ReturnDataPtr_numrhsevals_set, doc=' number of right hand side evaluations forward problem (shape `nt`)')
    numrhsevalsB = property(_amici.ReturnDataPtr_numrhsevalsB_get, _amici.ReturnDataPtr_numrhsevalsB_set, doc=' number of right hand side evaluations backward problem (shape `nt`)')
    numerrtestfails = property(_amici.ReturnDataPtr_numerrtestfails_get, _amici.ReturnDataPtr_numerrtestfails_set, doc=' number of error test failures forward problem (shape `nt`)')
    numerrtestfailsB = property(_amici.ReturnDataPtr_numerrtestfailsB_get, _amici.ReturnDataPtr_numerrtestfailsB_set, doc=' number of error test failures backward problem (shape `nt`)')
    numnonlinsolvconvfails = property(_amici.ReturnDataPtr_numnonlinsolvconvfails_get, _amici.ReturnDataPtr_numnonlinsolvconvfails_set, doc='number of linear solver convergence failures forward problem (shape `nt`)')
    numnonlinsolvconvfailsB = property(_amici.ReturnDataPtr_numnonlinsolvconvfailsB_get, _amici.ReturnDataPtr_numnonlinsolvconvfailsB_set, doc='\n    number of linear solver convergence failures backward problem (shape\n    `nt`)\n    ')
    order = property(_amici.ReturnDataPtr_order_get, _amici.ReturnDataPtr_order_set, doc=' employed order forward problem (shape `nt`)')
    cpu_time = property(_amici.ReturnDataPtr_cpu_time_get, _amici.ReturnDataPtr_cpu_time_set, doc='\n    computation time of forward solve [ms]\n\n    .. warning::\n         If AMICI was built without boost, this tracks the CPU-time of the\n         current process. Therefore, in a multi-threaded context, this value\n         may be incorrect.\n    ')
    cpu_timeB = property(_amici.ReturnDataPtr_cpu_timeB_get, _amici.ReturnDataPtr_cpu_timeB_set, doc='\n    computation time of backward solve [ms]\n\n    .. warning::\n         If AMICI was built without boost, this tracks the CPU-time of the\n         current process. Therefore, in a multi-threaded context, this value\n         may be incorrect.\n    ')
    cpu_time_total = property(_amici.ReturnDataPtr_cpu_time_total_get, _amici.ReturnDataPtr_cpu_time_total_set, doc='\n    total CPU time from entering runAmiciSimulation until exiting [ms]\n\n    .. warning::\n         If AMICI was built without boost, this tracks the CPU-time of the\n         current process. Therefore, in a multi-threaded context, this value\n         may be incorrect.\n    ')
    preeq_status = property(_amici.ReturnDataPtr_preeq_status_get, _amici.ReturnDataPtr_preeq_status_set, doc=' flags indicating success of steady state solver (preequilibration)')
    preeq_cpu_time = property(_amici.ReturnDataPtr_preeq_cpu_time_get, _amici.ReturnDataPtr_preeq_cpu_time_set, doc='\n    computation time of the steady state solver [ms]\n    (preequilibration)\n\n    .. warning::\n         If AMICI was built without boost, this tracks the CPU-time of the\n         current process. Therefore, in a multi-threaded context, this value\n         may be incorrect.\n    ')
    preeq_cpu_timeB = property(_amici.ReturnDataPtr_preeq_cpu_timeB_get, _amici.ReturnDataPtr_preeq_cpu_timeB_set, doc='\n    computation time of the steady state solver of the backward\n    problem [ms] (preequilibration)\n\n    .. warning::\n         If AMICI was built without boost, this tracks the CPU-time of the\n         current process. Therefore, in a multi-threaded context, this value\n         may be incorrect.\n    ')
    posteq_status = property(_amici.ReturnDataPtr_posteq_status_get, _amici.ReturnDataPtr_posteq_status_set, doc=' flags indicating success of steady state solver  (postequilibration)')
    posteq_cpu_time = property(_amici.ReturnDataPtr_posteq_cpu_time_get, _amici.ReturnDataPtr_posteq_cpu_time_set, doc='\n    computation time of the steady state solver [ms]\n    (postequilibration)\n\n    .. warning::\n         If AMICI was built without boost, this tracks the CPU-time of the\n         current process. Therefore, in a multi-threaded context, this value\n         may be incorrect.\n    ')
    posteq_cpu_timeB = property(_amici.ReturnDataPtr_posteq_cpu_timeB_get, _amici.ReturnDataPtr_posteq_cpu_timeB_set, doc='\n    computation time of the steady state solver of the backward\n    problem [ms] (postequilibration)\n\n    .. warning::\n         If AMICI was built without boost, this tracks the CPU-time of the\n         current process. Therefore, in a multi-threaded context, this value\n         may be incorrect.\n    ')
    preeq_numsteps = property(_amici.ReturnDataPtr_preeq_numsteps_get, _amici.ReturnDataPtr_preeq_numsteps_set, doc='\n    number of Newton steps for steady state problem (preequilibration)\n    [newton, simulation, newton] (length = 3)\n    ')
    preeq_numstepsB = property(_amici.ReturnDataPtr_preeq_numstepsB_get, _amici.ReturnDataPtr_preeq_numstepsB_set, doc='\n    number of simulation steps for adjoint steady state problem\n    (preequilibration) [== 0 if analytical solution worked, > 0 otherwise]\n    ')
    posteq_numsteps = property(_amici.ReturnDataPtr_posteq_numsteps_get, _amici.ReturnDataPtr_posteq_numsteps_set, doc='\n    number of Newton steps for steady state problem (preequilibration)\n    [newton, simulation, newton] (shape `3`) (postequilibration)\n    ')
    posteq_numstepsB = property(_amici.ReturnDataPtr_posteq_numstepsB_get, _amici.ReturnDataPtr_posteq_numstepsB_set, doc='\n    number of simulation steps for adjoint steady state problem\n    (postequilibration) [== 0 if analytical solution worked, > 0 otherwise]\n    ')
    preeq_t = property(_amici.ReturnDataPtr_preeq_t_get, _amici.ReturnDataPtr_preeq_t_set, doc='time when steadystate was reached via simulation (preequilibration)')
    preeq_wrms = property(_amici.ReturnDataPtr_preeq_wrms_get, _amici.ReturnDataPtr_preeq_wrms_set, doc='\n    weighted root-mean-square of the rhs when steadystate\n    was reached (preequilibration)\n    ')
    posteq_t = property(_amici.ReturnDataPtr_posteq_t_get, _amici.ReturnDataPtr_posteq_t_set, doc='time when steadystate was reached via simulation (postequilibration)')
    posteq_wrms = property(_amici.ReturnDataPtr_posteq_wrms_get, _amici.ReturnDataPtr_posteq_wrms_set, doc='\n    weighted root-mean-square of the rhs when steadystate\n    was reached (postequilibration)\n    ')
    x0 = property(_amici.ReturnDataPtr_x0_get, _amici.ReturnDataPtr_x0_set, doc=' initial state (shape `nx`)')
    x_ss = property(_amici.ReturnDataPtr_x_ss_get, _amici.ReturnDataPtr_x_ss_set, doc=' preequilibration steady state (shape `nx`)')
    sx0 = property(_amici.ReturnDataPtr_sx0_get, _amici.ReturnDataPtr_sx0_set, doc=' initial sensitivities (shape `nplist` x `nx`, row-major)')
    sx_ss = property(_amici.ReturnDataPtr_sx_ss_get, _amici.ReturnDataPtr_sx_ss_set, doc='\n    preequilibration sensitivities\n    (shape `nplist` x `nx`, row-major)\n    ')
    llh = property(_amici.ReturnDataPtr_llh_get, _amici.ReturnDataPtr_llh_set, doc=' log-likelihood value')
    chi2 = property(_amici.ReturnDataPtr_chi2_get, _amici.ReturnDataPtr_chi2_set, doc=' :math:`\\chi^2` value')
    sllh = property(_amici.ReturnDataPtr_sllh_get, _amici.ReturnDataPtr_sllh_set, doc=' parameter derivative of log-likelihood (shape `nplist`)')
    s2llh = property(_amici.ReturnDataPtr_s2llh_get, _amici.ReturnDataPtr_s2llh_set, doc='\n    second-order parameter derivative of log-likelihood\n    (shape `nJ-1` x `nplist`, row-major)\n    ')
    status = property(_amici.ReturnDataPtr_status_get, _amici.ReturnDataPtr_status_set, doc='\n    Simulation status code.\n\n    One of:\n\n    * AMICI_SUCCESS, indicating successful simulation\n    * AMICI_MAX_TIME_EXCEEDED, indicating that the simulation did not finish\n      within the allowed time (see Solver.{set,get}MaxTime)\n    * AMICI_ERROR, indicating that some error occurred during simulation\n      (a more detailed error message will have been printed).\n    * AMICI_NOT_RUN, if no simulation was started\n    ')
    nx = property(_amici.ReturnDataPtr_nx_get, _amici.ReturnDataPtr_nx_set, doc=' number of states (alias `nx_rdata`, kept for backward compatibility)')
    nxtrue = property(_amici.ReturnDataPtr_nxtrue_get, _amici.ReturnDataPtr_nxtrue_set, doc='\n    number of states in the unaugmented system\n    (alias nxtrue_rdata, kept for backward compatibility)\n    ')
    nplist = property(_amici.ReturnDataPtr_nplist_get, _amici.ReturnDataPtr_nplist_set, doc=' number of parameter for which sensitivities were requested')
    nmaxevent = property(_amici.ReturnDataPtr_nmaxevent_get, _amici.ReturnDataPtr_nmaxevent_set, doc=' maximal number of occurring events (for every event type)')
    nt = property(_amici.ReturnDataPtr_nt_get, _amici.ReturnDataPtr_nt_set, doc=' number of considered timepoints')
    newton_maxsteps = property(_amici.ReturnDataPtr_newton_maxsteps_get, _amici.ReturnDataPtr_newton_maxsteps_set, doc=' maximal number of newton iterations for steady state calculation')
    pscale = property(_amici.ReturnDataPtr_pscale_get, _amici.ReturnDataPtr_pscale_set, doc=' scaling of parameterization')
    o2mode = property(_amici.ReturnDataPtr_o2mode_get, _amici.ReturnDataPtr_o2mode_set, doc=' flag indicating whether second-order sensitivities were requested')
    sensi = property(_amici.ReturnDataPtr_sensi_get, _amici.ReturnDataPtr_sensi_set, doc=' sensitivity order')
    sensi_meth = property(_amici.ReturnDataPtr_sensi_meth_get, _amici.ReturnDataPtr_sensi_meth_set, doc=' sensitivity method')
    rdata_reporting = property(_amici.ReturnDataPtr_rdata_reporting_get, _amici.ReturnDataPtr_rdata_reporting_set, doc=' reporting mode')
    sigma_res = property(_amici.ReturnDataPtr_sigma_res_get, _amici.ReturnDataPtr_sigma_res_set, doc='\n     boolean indicating whether residuals for standard deviations have been\n    added\n    ')
    messages = property(_amici.ReturnDataPtr_messages_get, _amici.ReturnDataPtr_messages_set, doc=' log messages')
    t_last = property(_amici.ReturnDataPtr_t_last_get, _amici.ReturnDataPtr_t_last_set, doc=' The final internal time of the solver.')
    nx_rdata = property(_amici.ReturnDataPtr_nx_rdata_get, _amici.ReturnDataPtr_nx_rdata_set, doc=' Number of states')
    nxtrue_rdata = property(_amici.ReturnDataPtr_nxtrue_rdata_get, _amici.ReturnDataPtr_nxtrue_rdata_set, doc=' Number of states in the unaugmented system')
    nx_solver = property(_amici.ReturnDataPtr_nx_solver_get, _amici.ReturnDataPtr_nx_solver_set, doc=' Number of states with conservation laws applied')
    nxtrue_solver = property(_amici.ReturnDataPtr_nxtrue_solver_get, _amici.ReturnDataPtr_nxtrue_solver_set, doc='\n    Number of states in the unaugmented system with conservation laws\n    applied\n    ')
    nx_solver_reinit = property(_amici.ReturnDataPtr_nx_solver_reinit_get, _amici.ReturnDataPtr_nx_solver_reinit_set, doc=' Number of solver states subject to reinitialization')
    np = property(_amici.ReturnDataPtr_np_get, _amici.ReturnDataPtr_np_set, doc=' Number of parameters')
    nk = property(_amici.ReturnDataPtr_nk_get, _amici.ReturnDataPtr_nk_set, doc=' Number of constants')
    ny = property(_amici.ReturnDataPtr_ny_get, _amici.ReturnDataPtr_ny_set, doc=' Number of observables')
    nytrue = property(_amici.ReturnDataPtr_nytrue_get, _amici.ReturnDataPtr_nytrue_set, doc=' Number of observables in the unaugmented system')
    nz = property(_amici.ReturnDataPtr_nz_get, _amici.ReturnDataPtr_nz_set, doc=' Number of event outputs')
    nztrue = property(_amici.ReturnDataPtr_nztrue_get, _amici.ReturnDataPtr_nztrue_set, doc=' Number of event outputs in the unaugmented system')
    ne = property(_amici.ReturnDataPtr_ne_get, _amici.ReturnDataPtr_ne_set, doc=' Number of events')
    ne_solver = property(_amici.ReturnDataPtr_ne_solver_get, _amici.ReturnDataPtr_ne_solver_set, doc=' Number of events that require root-finding')
    nspl = property(_amici.ReturnDataPtr_nspl_get, _amici.ReturnDataPtr_nspl_set, doc=' Number of spline functions in the model')
    nw = property(_amici.ReturnDataPtr_nw_get, _amici.ReturnDataPtr_nw_set, doc=' Number of common expressions')
    ndwdx = property(_amici.ReturnDataPtr_ndwdx_get, _amici.ReturnDataPtr_ndwdx_set, doc='\n    Number of nonzero elements in the `x` derivative of the\n    repeating elements\n    ')
    ndwdp = property(_amici.ReturnDataPtr_ndwdp_get, _amici.ReturnDataPtr_ndwdp_set, doc='\n    Number of nonzero elements in the `p` derivative of the\n    repeating elements\n    ')
    ndwdw = property(_amici.ReturnDataPtr_ndwdw_get, _amici.ReturnDataPtr_ndwdw_set, doc='\n    Number of nonzero elements in the `w` derivative of the\n    repeating elements\n    ')
    ndxdotdw = property(_amici.ReturnDataPtr_ndxdotdw_get, _amici.ReturnDataPtr_ndxdotdw_set, doc=' Number of nonzero elements in the :math:`w` derivative of :math:`xdot`')
    ndJydy = property(_amici.ReturnDataPtr_ndJydy_get, _amici.ReturnDataPtr_ndJydy_set, doc='\n    Number of nonzero elements in the :math:`y` derivative of\n    :math:`dJy` (dimension `nytrue`)\n    ')
    ndxrdatadxsolver = property(_amici.ReturnDataPtr_ndxrdatadxsolver_get, _amici.ReturnDataPtr_ndxrdatadxsolver_set, doc=' Number of nonzero elements in the :math:`x` derivative of :math:`x_rdata`')
    ndxrdatadtcl = property(_amici.ReturnDataPtr_ndxrdatadtcl_get, _amici.ReturnDataPtr_ndxrdatadtcl_set, doc=' Number of nonzero elements in the :math:`tcl` derivative of :math:`x_rdata`')
    ndtotal_cldx_rdata = property(_amici.ReturnDataPtr_ndtotal_cldx_rdata_get, _amici.ReturnDataPtr_ndtotal_cldx_rdata_set, doc='\n    Number of nonzero elements in the :math:`x_rdata` derivative of\n    :math:`total_cl`\n    ')
    nnz = property(_amici.ReturnDataPtr_nnz_get, _amici.ReturnDataPtr_nnz_set, doc=' Number of nonzero entries in Jacobian')
    nJ = property(_amici.ReturnDataPtr_nJ_get, _amici.ReturnDataPtr_nJ_set, doc=' Dimension of the augmented objective function for 2nd order ASA')
    ubw = property(_amici.ReturnDataPtr_ubw_get, _amici.ReturnDataPtr_ubw_set, doc=' Upper bandwidth of the Jacobian')
    lbw = property(_amici.ReturnDataPtr_lbw_get, _amici.ReturnDataPtr_lbw_set, doc=' Lower bandwidth of the Jacobian')
_amici.ReturnDataPtr_swigregister(ReturnDataPtr)

class ModelPtr(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _amici.ModelPtr_swiginit(self, _amici.new_ModelPtr(*args))

    def __deref__(self):
        return _amici.ModelPtr___deref__(self)

    def release(self):
        return _amici.ModelPtr_release(self)

    def reset(self, *args):
        return _amici.ModelPtr_reset(self, *args)

    def swap(self, __u):
        return _amici.ModelPtr_swap(self, __u)

    def get(self):
        return _amici.ModelPtr_get(self)

    def __nonzero__(self):
        return _amici.ModelPtr___nonzero__(self)
    __bool__ = __nonzero__
    __swig_destroy__ = _amici.delete_ModelPtr

    def __deepcopy__(self, memo):
        return self.clone()

    def clone(self) -> 'Model':
        """
        Clone this instance.
        :return: The clone
        """
        return _amici.ModelPtr_clone(self)

    def initializeSplines(self):
        """Initialization of spline functions"""
        return _amici.ModelPtr_initializeSplines(self)

    def initializeSplineSensitivities(self):
        """Initialization of spline sensitivity functions"""
        return _amici.ModelPtr_initializeSplineSensitivities(self)

    def nplist(self) -> int:
        """
        Get number of parameters wrt to which sensitivities are computed.
        :return: Length of sensitivity index vector
        """
        return _amici.ModelPtr_nplist(self)

    def np(self) -> int:
        """
        Get total number of model parameters.
        :return: Length of parameter vector
        """
        return _amici.ModelPtr_np(self)

    def nk(self) -> int:
        """
        Get number of constants
        :return: Length of constant vector
        """
        return _amici.ModelPtr_nk(self)

    def ncl(self) -> int:
        """
        Get number of conservation laws.
        :return: Number of conservation laws (i.e., difference between `nx_rdata`
            and `nx_solver`).
        """
        return _amici.ModelPtr_ncl(self)

    def nx_reinit(self) -> int:
        """
        Get number of solver states subject to reinitialization.
        :return: Model member `nx_solver_reinit`
        """
        return _amici.ModelPtr_nx_reinit(self)

    def k(self) -> 'float':
        """
        Get fixed parameters.
        :return: Pointer to constants array
        """
        return _amici.ModelPtr_k(self)

    def nMaxEvent(self) -> int:
        """
        Get maximum number of events that may occur for each type.
        :return: Maximum number of events that may occur for each type
        """
        return _amici.ModelPtr_nMaxEvent(self)

    def setNMaxEvent(self, nmaxevent: int):
        """
        Set maximum number of events that may occur for each type.
        :param nmaxevent: Maximum number of events that may occur for each type
        """
        return _amici.ModelPtr_setNMaxEvent(self, nmaxevent)

    def nt(self) -> int:
        """
        Get number of timepoints.
        :return: Number of timepoints
        """
        return _amici.ModelPtr_nt(self)

    def getParameterScale(self) -> 'ParameterScalingVector':
        """
        Get parameter scale for each parameter.
        :return: Vector of parameter scales
        """
        return _amici.ModelPtr_getParameterScale(self)

    def setParameterScale(self, *args):
        return _amici.ModelPtr_setParameterScale(self, *args)

    def getUnscaledParameters(self) -> Sequence[float]:
        """
        Get parameters with transformation according to parameter scale
        applied.
        :return: Unscaled parameters
        """
        return _amici.ModelPtr_getUnscaledParameters(self)

    def getParameters(self) -> Sequence[float]:
        """
        Get parameter vector.
        :return: The user-set parameters (see also `Model::getUnscaledParameters`)
        """
        return _amici.ModelPtr_getParameters(self)

    def getParameterById(self, par_id: 'str') -> 'float':
        """
        Get value of first model parameter with the specified ID.
        :param par_id: Parameter ID
        :return: Parameter value
        """
        return _amici.ModelPtr_getParameterById(self, par_id)

    def getParameterByName(self, par_name: 'str') -> 'float':
        """
        Get value of first model parameter with the specified name.
        :param par_name: Parameter name
        :return: Parameter value
        """
        return _amici.ModelPtr_getParameterByName(self, par_name)

    def setParameters(self, p: Sequence[float]):
        """
        Set the parameter vector.
        :param p: Vector of parameters
        """
        return _amici.ModelPtr_setParameters(self, p)

    def setParameterById(self, *args):
        """
        *Overload 1:*

        Set model parameters according to the parameter IDs and mapped
        values.
        :type p: StringDoubleMap
        :param p: Map of parameters IDs and values
        :type ignoreErrors: boolean, optional
        :param ignoreErrors: Ignore errors such as parameter IDs in p which are
            not model parameters

        |

        *Overload 2:*

        Set value of first model parameter with the specified ID.
        :type par_id: str
        :param par_id: Parameter ID
        :type value: float
        :param value: Parameter value
        """
        return _amici.ModelPtr_setParameterById(self, *args)

    def setParametersByIdRegex(self, par_id_regex: 'str', value: 'float') -> int:
        """
        Set all values of model parameters with IDs matching the specified
        regular expression.
        :param par_id_regex: Parameter ID regex
        :param value: Parameter value
        :return: Number of parameter IDs that matched the regex
        """
        return _amici.ModelPtr_setParametersByIdRegex(self, par_id_regex, value)

    def setParameterByName(self, *args):
        """
        *Overload 1:*

        Set value of first model parameter with the specified name.
        :type par_name: str
        :param par_name: Parameter name
        :type value: float
        :param value: Parameter value

        |

        *Overload 2:*

        Set model parameters according to the parameter name and mapped
        values.
        :type p: StringDoubleMap
        :param p: Map of parameters names and values
        :type ignoreErrors: boolean, optional
        :param ignoreErrors: Ignore errors such as parameter names in p which are
            not model parameters

        |

        *Overload 3:*

        Set model parameters according to the parameter name and mapped
        values.
        :type p: StringDoubleMap
        :param p: Map of parameters names and values
        :param ignoreErrors: Ignore errors such as parameter names in p which are
            not model parameters
        """
        return _amici.ModelPtr_setParameterByName(self, *args)

    def setParametersByNameRegex(self, par_name_regex: 'str', value: 'float') -> int:
        """
        Set all values of all model parameters with names matching the
        specified regex.
        :param par_name_regex: Parameter name regex
        :param value: Parameter value
        :return: Number of fixed parameter names that matched the regex
        """
        return _amici.ModelPtr_setParametersByNameRegex(self, par_name_regex, value)

    def getFixedParameters(self) -> Sequence[float]:
        """
        Get values of fixed parameters.
        :return: Vector of fixed parameters with same ordering as in
            Model::getFixedParameterIds
        """
        return _amici.ModelPtr_getFixedParameters(self)

    def getFixedParameterById(self, par_id: 'str') -> 'float':
        """
        Get value of fixed parameter with the specified ID.
        :param par_id: Parameter ID
        :return: Parameter value
        """
        return _amici.ModelPtr_getFixedParameterById(self, par_id)

    def getFixedParameterByName(self, par_name: 'str') -> 'float':
        """
        Get value of fixed parameter with the specified name.

        If multiple parameters have the same name, the first parameter with
        matching name is returned.

        :param par_name: Parameter name
        :return: Parameter value
        """
        return _amici.ModelPtr_getFixedParameterByName(self, par_name)

    def setFixedParameters(self, k: Sequence[float]):
        """
        Set values for constants.
        :param k: Vector of fixed parameters
        """
        return _amici.ModelPtr_setFixedParameters(self, k)

    def setFixedParameterById(self, par_id: 'str', value: 'float'):
        """
        Set value of first fixed parameter with the specified ID.
        :param par_id: Fixed parameter id
        :param value: Fixed parameter value
        """
        return _amici.ModelPtr_setFixedParameterById(self, par_id, value)

    def setFixedParametersByIdRegex(self, par_id_regex: 'str', value: 'float') -> int:
        """
        Set values of all fixed parameters with the ID matching the
        specified regex.
        :param par_id_regex: Fixed parameter name regex
        :param value: Fixed parameter value
        :return: Number of fixed parameter IDs that matched the regex
        """
        return _amici.ModelPtr_setFixedParametersByIdRegex(self, par_id_regex, value)

    def setFixedParameterByName(self, par_name: 'str', value: 'float'):
        """
        Set value of first fixed parameter with the specified name.
        :param par_name: Fixed parameter ID
        :param value: Fixed parameter value
        """
        return _amici.ModelPtr_setFixedParameterByName(self, par_name, value)

    def setFixedParametersByNameRegex(self, par_name_regex: 'str', value: 'float') -> int:
        """
        Set value of all fixed parameters with name matching the specified
        regex.
        :param par_name_regex: Fixed parameter name regex
        :param value: Fixed parameter value
        :return: Number of fixed parameter names that matched the regex
        """
        return _amici.ModelPtr_setFixedParametersByNameRegex(self, par_name_regex, value)

    def getName(self) -> 'str':
        """
        Get the model name.
        :return: Model name
        """
        return _amici.ModelPtr_getName(self)

    def hasParameterNames(self) -> bool:
        """
        Report whether the model has parameter names set.

        :return: Boolean indicating whether parameter names were set. Also returns
            `true` if the number of corresponding variables is just zero.
        """
        return _amici.ModelPtr_hasParameterNames(self)

    def getParameterNames(self) -> Sequence[str]:
        """
        Get names of the model parameters.
        :return: The parameter names
        """
        return _amici.ModelPtr_getParameterNames(self)

    def hasStateNames(self) -> bool:
        """
        Report whether the model has state names set.

        :return: Boolean indicating whether state names were set. Also returns
            `true` if the number of corresponding variables is just zero.
        """
        return _amici.ModelPtr_hasStateNames(self)

    def getStateNames(self) -> Sequence[str]:
        """
        Get names of the model states.
        :return: State names
        """
        return _amici.ModelPtr_getStateNames(self)

    def getStateNamesSolver(self) -> Sequence[str]:
        """
        Get names of the solver states.
        :return: State names
        """
        return _amici.ModelPtr_getStateNamesSolver(self)

    def hasFixedParameterNames(self) -> bool:
        """
        Report whether the model has fixed parameter names set.
        :return: Boolean indicating whether fixed parameter names were set. Also
            returns `true` if the number of corresponding variables is just zero.
        """
        return _amici.ModelPtr_hasFixedParameterNames(self)

    def getFixedParameterNames(self) -> Sequence[str]:
        """
        Get names of the fixed model parameters.
        :return: Fixed parameter names
        """
        return _amici.ModelPtr_getFixedParameterNames(self)

    def hasObservableNames(self) -> bool:
        """
        Report whether the model has observable names set.
        :return: Boolean indicating whether observable names were set. Also
            returns `true` if the number of corresponding variables is just zero.
        """
        return _amici.ModelPtr_hasObservableNames(self)

    def getObservableNames(self) -> Sequence[str]:
        """
        Get names of the observables.
        :return: Observable names
        """
        return _amici.ModelPtr_getObservableNames(self)

    def hasExpressionNames(self) -> bool:
        """
        Report whether the model has expression names set.
        :return: Boolean indicating whether expression names were set. Also
            returns `true` if the number of corresponding variables is just zero.
        """
        return _amici.ModelPtr_hasExpressionNames(self)

    def getExpressionNames(self) -> Sequence[str]:
        """
        Get names of the expressions.
        :return: Expression names
        """
        return _amici.ModelPtr_getExpressionNames(self)

    def hasParameterIds(self) -> bool:
        """
        Report whether the model has parameter IDs set.
        :return: Boolean indicating whether parameter IDs were set. Also returns
            `true` if the number of corresponding variables is just zero.
        """
        return _amici.ModelPtr_hasParameterIds(self)

    def getParameterIds(self) -> Sequence[str]:
        """
        Get IDs of the model parameters.
        :return: Parameter IDs
        """
        return _amici.ModelPtr_getParameterIds(self)

    def hasStateIds(self) -> bool:
        """
        Report whether the model has state IDs set.
        :return: Boolean indicating whether state IDs were set. Also returns
            `true` if the number of corresponding variables is just zero.
        """
        return _amici.ModelPtr_hasStateIds(self)

    def getStateIds(self) -> Sequence[str]:
        """
        Get IDs of the model states.
        :return: State IDs
        """
        return _amici.ModelPtr_getStateIds(self)

    def getStateIdsSolver(self) -> Sequence[str]:
        """
        Get IDs of the solver states.
        :return: State IDs
        """
        return _amici.ModelPtr_getStateIdsSolver(self)

    def hasFixedParameterIds(self) -> bool:
        """
        Report whether the model has fixed parameter IDs set.
        :return: Boolean indicating whether fixed parameter IDs were set. Also
            returns `true` if the number of corresponding variables is just zero.
        """
        return _amici.ModelPtr_hasFixedParameterIds(self)

    def getFixedParameterIds(self) -> Sequence[str]:
        """
        Get IDs of the fixed model parameters.
        :return: Fixed parameter IDs
        """
        return _amici.ModelPtr_getFixedParameterIds(self)

    def hasObservableIds(self) -> bool:
        """
        Report whether the model has observable IDs set.
        :return: Boolean indicating whether observable ids were set. Also returns
            `true` if the number of corresponding variables is just zero.
        """
        return _amici.ModelPtr_hasObservableIds(self)

    def getObservableIds(self) -> Sequence[str]:
        """
        Get IDs of the observables.
        :return: Observable IDs
        """
        return _amici.ModelPtr_getObservableIds(self)

    def hasExpressionIds(self) -> bool:
        """
        Report whether the model has expression IDs set.
        :return: Boolean indicating whether expression ids were set. Also returns
            `true` if the number of corresponding variables is just zero.
        """
        return _amici.ModelPtr_hasExpressionIds(self)

    def getExpressionIds(self) -> Sequence[str]:
        """
        Get IDs of the expression.
        :return: Expression IDs
        """
        return _amici.ModelPtr_getExpressionIds(self)

    def hasQuadraticLLH(self) -> bool:
        """
        Checks whether the defined noise model is gaussian, i.e., the nllh
        is quadratic
        :return: boolean flag
        """
        return _amici.ModelPtr_hasQuadraticLLH(self)

    def getTimepoints(self) -> Sequence[float]:
        """
        Get the timepoint vector.
        :return: Timepoint vector
        """
        return _amici.ModelPtr_getTimepoints(self)

    def getTimepoint(self, it: int) -> 'float':
        """
        Get simulation timepoint for time index `it`.
        :param it: Time index
        :return: Timepoint
        """
        return _amici.ModelPtr_getTimepoint(self, it)

    def setTimepoints(self, ts: Sequence[float]):
        """
        Set the timepoint vector.
        :param ts: New timepoint vector
        """
        return _amici.ModelPtr_setTimepoints(self, ts)

    def t0(self) -> 'float':
        """
        Get simulation start time.
        :return: Simulation start time
        """
        return _amici.ModelPtr_t0(self)

    def setT0(self, t0: 'float'):
        """
        Set simulation start time.

        Output timepoints are absolute timepoints, independent of
        :math:`t_{0}`.
        For output timepoints :math:`t <  t_{0}`, the initial state will be
        returned.

        :param t0: Simulation start time
        """
        return _amici.ModelPtr_setT0(self, t0)

    def getStateIsNonNegative(self) -> Sequence[bool]:
        """
        Get flags indicating whether states should be treated as
        non-negative.
        :return: Vector of flags
        """
        return _amici.ModelPtr_getStateIsNonNegative(self)

    def setStateIsNonNegative(self, stateIsNonNegative: Sequence[bool]):
        """
        Set flags indicating whether states should be treated as
        non-negative.
        :param stateIsNonNegative: Vector of flags
        """
        return _amici.ModelPtr_setStateIsNonNegative(self, stateIsNonNegative)

    def setAllStatesNonNegative(self):
        """
        Set flags indicating that all states should be treated as
        non-negative.
        """
        return _amici.ModelPtr_setAllStatesNonNegative(self)

    def setMinimumSigmaResiduals(self, min_sigma: 'float'):
        """
        Sets the estimated lower boundary for sigma_y. When
        :meth:`setAddSigmaResiduals` is activated, this lower boundary must
        ensure that log(sigma) + min_sigma > 0.
        :param min_sigma: lower boundary
        """
        return _amici.ModelPtr_setMinimumSigmaResiduals(self, min_sigma)

    def getMinimumSigmaResiduals(self) -> 'float':
        """
        Gets the specified estimated lower boundary for sigma_y.
        :return: lower boundary
        """
        return _amici.ModelPtr_getMinimumSigmaResiduals(self)

    def setAddSigmaResiduals(self, sigma_res: bool):
        """
        Specifies whether residuals should be added to account for
        parameter dependent sigma.

        If set to true, additional residuals of the form :math:`\\sqrt{\\log(\\sigma) +C}` will be added. This enables least-squares optimization for
        variables with Gaussian noise assumption and parameter dependent standard
        deviation sigma. The constant :math:`C` can be set via
        :meth:`setMinimumSigmaResiduals`.

        :param sigma_res: if true, additional residuals are added
        """
        return _amici.ModelPtr_setAddSigmaResiduals(self, sigma_res)

    def getAddSigmaResiduals(self) -> bool:
        """
        Checks whether residuals should be added to account for parameter
        dependent sigma.
        :return: sigma_res
        """
        return _amici.ModelPtr_getAddSigmaResiduals(self)

    def getParameterList(self) -> Sequence[int]:
        """
        Get the list of parameters for which sensitivities are computed.
        :return: List of parameter indices
        """
        return _amici.ModelPtr_getParameterList(self)

    def plist(self, pos: int) -> int:
        """
        Get entry in parameter list by index.
        :param pos: Index in sensitivity parameter list
        :return: Index in parameter list
        """
        return _amici.ModelPtr_plist(self, pos)

    def setParameterList(self, plist: Sequence[int]):
        """
        Set the list of parameters for which sensitivities are to be
        computed.

        NOTE: Resets initial state sensitivities.

        :param plist: List of parameter indices
        """
        return _amici.ModelPtr_setParameterList(self, plist)

    def getInitialStates(self) -> Sequence[float]:
        """
        Get the initial states.
        :return: Initial state vector
        """
        return _amici.ModelPtr_getInitialStates(self)

    def setInitialStates(self, x0: Sequence[float]):
        """
        Set the initial states.
        :param x0: Initial state vector
        """
        return _amici.ModelPtr_setInitialStates(self, x0)

    def hasCustomInitialStates(self) -> bool:
        """
        Return whether custom initial states have been set.
        :return: `true` if has custom initial states, otherwise `false`
        """
        return _amici.ModelPtr_hasCustomInitialStates(self)

    def getInitialStateSensitivities(self) -> Sequence[float]:
        """
        Get the initial states sensitivities.
        :return: vector of initial state sensitivities
        """
        return _amici.ModelPtr_getInitialStateSensitivities(self)

    def setInitialStateSensitivities(self, sx0: Sequence[float]):
        """
        Set the initial state sensitivities.
        :param sx0: vector of initial state sensitivities with chainrule applied.
            This could be a slice of ReturnData::sx or ReturnData::sx0
        """
        return _amici.ModelPtr_setInitialStateSensitivities(self, sx0)

    def hasCustomInitialStateSensitivities(self) -> bool:
        """
        Return whether custom initial state sensitivities have been set.
        :return: `true` if has custom initial state sensitivities, otherwise
            `false`.
        """
        return _amici.ModelPtr_hasCustomInitialStateSensitivities(self)

    def setUnscaledInitialStateSensitivities(self, sx0: Sequence[float]):
        """
        Set the initial state sensitivities.
        :param sx0: Vector of initial state sensitivities without chainrule
            applied. This could be the readin from a `model.sx0data` saved to HDF5.
        """
        return _amici.ModelPtr_setUnscaledInitialStateSensitivities(self, sx0)

    def setSteadyStateComputationMode(self, mode: int):
        """
        Set the mode how steady state is computed in the steadystate
        simulation.
        :param mode: Steadystate computation mode
        """
        return _amici.ModelPtr_setSteadyStateComputationMode(self, mode)

    def getSteadyStateComputationMode(self) -> int:
        """
        Gets the mode how steady state is computed in the steadystate
        simulation.
        :return: Mode
        """
        return _amici.ModelPtr_getSteadyStateComputationMode(self)

    def setSteadyStateSensitivityMode(self, mode: 'SteadyStateSensitivityMode'):
        """
        Set the mode how sensitivities are computed in the steadystate
        simulation.
        :param mode: Steadystate sensitivity mode
        """
        return _amici.ModelPtr_setSteadyStateSensitivityMode(self, mode)

    def getSteadyStateSensitivityMode(self) -> 'SteadyStateSensitivityMode':
        """
        Gets the mode how sensitivities are computed in the steadystate
        simulation.
        :return: Mode
        """
        return _amici.ModelPtr_getSteadyStateSensitivityMode(self)

    def setReinitializeFixedParameterInitialStates(self, flag: bool):
        """
        Set whether initial states depending on fixed parameters are to be
        reinitialized after preequilibration and presimulation.
        :param flag: Fixed parameters reinitialized?
        """
        return _amici.ModelPtr_setReinitializeFixedParameterInitialStates(self, flag)

    def getReinitializeFixedParameterInitialStates(self) -> bool:
        """
        Get whether initial states depending on fixedParameters are to be
        reinitialized after preequilibration and presimulation.
        :return: flag `true` / `false`
        """
        return _amici.ModelPtr_getReinitializeFixedParameterInitialStates(self)

    def requireSensitivitiesForAllParameters(self):
        """
        Require computation of sensitivities for all parameters p [0..np[
        in natural order.

        NOTE: Resets initial state sensitivities.
        """
        return _amici.ModelPtr_requireSensitivitiesForAllParameters(self)

    def getObservableScaling(self, iy: int) -> int:
        """
        Get scaling type for observable
        :param iy: observable index
        :return: scaling type
        """
        return _amici.ModelPtr_getObservableScaling(self, iy)

    def setAlwaysCheckFinite(self, alwaysCheck: bool):
        """
        Set whether the result of every call to `Model::f*` should be
        checked for finiteness.
        :param alwaysCheck:
        """
        return _amici.ModelPtr_setAlwaysCheckFinite(self, alwaysCheck)

    def getAlwaysCheckFinite(self) -> bool:
        """
        Get setting of whether the result of every call to `Model::f*`
        should be checked for finiteness.
        :return: that
        """
        return _amici.ModelPtr_getAlwaysCheckFinite(self)

    def setReinitializationStateIdxs(self, idxs: Sequence[int]):
        """
        Set indices of states to be reinitialized based on provided
        constants / fixed parameters
        :param idxs: Array of state indices
        """
        return _amici.ModelPtr_setReinitializationStateIdxs(self, idxs)

    def getReinitializationStateIdxs(self) -> Sequence[int]:
        """
        Return indices of states to be reinitialized based on provided
        constants / fixed parameters
        :return: Those indices.
        """
        return _amici.ModelPtr_getReinitializationStateIdxs(self)
    pythonGenerated = property(_amici.ModelPtr_pythonGenerated_get, _amici.ModelPtr_pythonGenerated_set, doc=' Flag indicating Matlab- or Python-based model generation')

    def get_trigger_timepoints(self) -> Sequence[float]:
        """
        Get trigger times for events that don't require root-finding.

        :return: List of unique trigger points for events that don't require
            root-finding (i.e. that trigger at predetermined timepoints),
            in ascending order.
        """
        return _amici.ModelPtr_get_trigger_timepoints(self)

    def get_steadystate_mask(self) -> Sequence[float]:
        """
        Get steady-state mask as std::vector.

        See `set_steadystate_mask` for details.

        :return: Steady-state mask
        """
        return _amici.ModelPtr_get_steadystate_mask(self)

    def set_steadystate_mask(self, mask: Sequence[float]):
        """
        Set steady-state mask.

        The mask is used to exclude certain state variables from the steady-state
        convergence check. Positive values indicate that the corresponding state
        variable should be included in the convergence check, while non-positive
        values indicate that the corresponding state variable should be excluded.
        An empty mask is interpreted as including all state variables.

        :param mask: Mask of length `nx_solver`.
        """
        return _amici.ModelPtr_set_steadystate_mask(self, mask)
    o2mode = property(_amici.ModelPtr_o2mode_get, _amici.ModelPtr_o2mode_set, doc='\n    Flag indicating whether for\n    `amici::Solver::sensi_` == `amici::SensitivityOrder::second`\n    directional or full second order derivative will be computed\n    ')
    idlist = property(_amici.ModelPtr_idlist_get, _amici.ModelPtr_idlist_set, doc=' Flag array for DAE equations')
    logger = property(_amici.ModelPtr_logger_get, _amici.ModelPtr_logger_set, doc=' Logger')
    state_independent_events_ = property(_amici.ModelPtr_state_independent_events__get, _amici.ModelPtr_state_independent_events__set, doc="\n    Map of trigger timepoints to event indices for events that don't\n    require root-finding.\n    ")

    def getSolver(self) -> 'Solver':
        """
        Retrieves the solver object
        :return: The Solver instance
        """
        return _amici.ModelPtr_getSolver(self)

    def getAmiciVersion(self) -> 'str':
        """
        Returns the AMICI version that was used to generate the model
        :return: AMICI version string
        """
        return _amici.ModelPtr_getAmiciVersion(self)

    def getAmiciCommit(self) -> 'str':
        """
        Returns the AMICI commit that was used to generate the model
        :return: AMICI commit string
        """
        return _amici.ModelPtr_getAmiciCommit(self)

    def isFixedParameterStateReinitializationAllowed(self) -> bool:
        """
        Function indicating whether reinitialization of states depending
        on fixed parameters is permissible
        :return: flag indicating whether reinitialization of states depending on
            fixed parameters is permissible
        """
        return _amici.ModelPtr_isFixedParameterStateReinitializationAllowed(self)

    def fdsigmaydy(self, dsigmaydy: 'float', t: 'float', p: 'float', k: 'float', y: 'float'):
        """
        Model-specific implementation of fsigmay
        :param dsigmaydy: partial derivative of standard deviation of measurements
            w.r.t. model outputs
        :param t: current time
        :param p: parameter vector
        :param k: constant vector
        :param y: model output at timepoint t
        """
        return _amici.ModelPtr_fdsigmaydy(self, dsigmaydy, t, p, k, y)

    def fdx_rdatadx_solver(self, dx_rdatadx_solver: 'float', x: 'float', tcl: 'float', p: 'float', k: 'float'):
        """
        Compute dx_rdata / dx_solver
        :param dx_rdatadx_solver: dx_rdata / dx_solver
        :param p: parameter vector
        :param k: constant vector
        :param x: State variables with conservation laws applied
        :param tcl: Total abundances for conservation laws
        """
        return _amici.ModelPtr_fdx_rdatadx_solver(self, dx_rdatadx_solver, x, tcl, p, k)

    def fdx_rdatadp(self, dx_rdatadp: 'float', x: 'float', tcl: 'float', p: 'float', k: 'float', ip: int):
        """
        Compute dx_rdata / dp
        :param dx_rdatadp: dx_rdata / dp
        :param p: parameter vector
        :param k: constant vector
        :param x: State variables with conservation laws applied
        :param tcl: Total abundances for conservation laws
        :param ip: Sensitivity index
        """
        return _amici.ModelPtr_fdx_rdatadp(self, dx_rdatadp, x, tcl, p, k, ip)

    def fdx_rdatadtcl(self, dx_rdatadtcl: 'float', x: 'float', tcl: 'float', p: 'float', k: 'float'):
        """
        Compute dx_rdata / dtcl
        :param dx_rdatadtcl: dx_rdata / dtcl
        :param p: parameter vector
        :param k: constant vector
        :param x: State variables with conservation laws applied
        :param tcl: Total abundances for conservation laws
        """
        return _amici.ModelPtr_fdx_rdatadtcl(self, dx_rdatadtcl, x, tcl, p, k)

    def fdtotal_cldp(self, dtotal_cldp: 'float', x_rdata: 'float', p: 'float', k: 'float', ip: int):
        """
        Compute dtotal_cl / dp
        :param dtotal_cldp: dtotal_cl / dp
        :param x_rdata: State variables with conservation laws applied
        :param p: parameter vector
        :param k: constant vector
        :param ip: Sensitivity index
        """
        return _amici.ModelPtr_fdtotal_cldp(self, dtotal_cldp, x_rdata, p, k, ip)

    def fdtotal_cldx_rdata(self, dtotal_cldx_rdata: 'float', x_rdata: 'float', p: 'float', k: 'float', tcl: 'float'):
        """
        Compute dtotal_cl / dx_rdata
        :param dtotal_cldx_rdata: dtotal_cl / dx_rdata
        :param x_rdata: State variables with conservation laws applied
        :param p: parameter vector
        :param k: constant vector
        :param tcl: Total abundances for conservation laws
        """
        return _amici.ModelPtr_fdtotal_cldx_rdata(self, dtotal_cldx_rdata, x_rdata, p, k, tcl)

    def fdspline_valuesdp(self, dspline_valuesdp: 'float', p: 'float', k: 'float', ip: int):
        """
        Model-specific implementation the parametric derivatives
        of spline node values
        :param dspline_valuesdp: vector to which derivatives will be written
        :param p: parameter vector
        :param k: constants vector
        :param ip: Sensitivity index
        """
        return _amici.ModelPtr_fdspline_valuesdp(self, dspline_valuesdp, p, k, ip)

    def fdspline_slopesdp(self, dspline_slopesdp: 'float', p: 'float', k: 'float', ip: int):
        """
        Model-specific implementation the parametric derivatives
        of slopevalues at spline nodes
        :param dspline_slopesdp: vector to which derivatives will be written
        :param p: parameter vector
        :param k: constants vector
        :param ip: Sensitivity index
        """
        return _amici.ModelPtr_fdspline_slopesdp(self, dspline_slopesdp, p, k, ip)
    nx_rdata = property(_amici.ModelPtr_nx_rdata_get, _amici.ModelPtr_nx_rdata_set, doc=' Number of states')
    nxtrue_rdata = property(_amici.ModelPtr_nxtrue_rdata_get, _amici.ModelPtr_nxtrue_rdata_set, doc=' Number of states in the unaugmented system')
    nx_solver = property(_amici.ModelPtr_nx_solver_get, _amici.ModelPtr_nx_solver_set, doc=' Number of states with conservation laws applied')
    nxtrue_solver = property(_amici.ModelPtr_nxtrue_solver_get, _amici.ModelPtr_nxtrue_solver_set, doc='\n    Number of states in the unaugmented system with conservation laws\n    applied\n    ')
    nx_solver_reinit = property(_amici.ModelPtr_nx_solver_reinit_get, _amici.ModelPtr_nx_solver_reinit_set, doc=' Number of solver states subject to reinitialization')
    ny = property(_amici.ModelPtr_ny_get, _amici.ModelPtr_ny_set, doc=' Number of observables')
    nytrue = property(_amici.ModelPtr_nytrue_get, _amici.ModelPtr_nytrue_set, doc=' Number of observables in the unaugmented system')
    nz = property(_amici.ModelPtr_nz_get, _amici.ModelPtr_nz_set, doc=' Number of event outputs')
    nztrue = property(_amici.ModelPtr_nztrue_get, _amici.ModelPtr_nztrue_set, doc=' Number of event outputs in the unaugmented system')
    ne = property(_amici.ModelPtr_ne_get, _amici.ModelPtr_ne_set, doc=' Number of events')
    ne_solver = property(_amici.ModelPtr_ne_solver_get, _amici.ModelPtr_ne_solver_set, doc=' Number of events that require root-finding')
    nspl = property(_amici.ModelPtr_nspl_get, _amici.ModelPtr_nspl_set, doc=' Number of spline functions in the model')
    nw = property(_amici.ModelPtr_nw_get, _amici.ModelPtr_nw_set, doc=' Number of common expressions')
    ndwdx = property(_amici.ModelPtr_ndwdx_get, _amici.ModelPtr_ndwdx_set, doc='\n    Number of nonzero elements in the `x` derivative of the\n    repeating elements\n    ')
    ndwdp = property(_amici.ModelPtr_ndwdp_get, _amici.ModelPtr_ndwdp_set, doc='\n    Number of nonzero elements in the `p` derivative of the\n    repeating elements\n    ')
    ndwdw = property(_amici.ModelPtr_ndwdw_get, _amici.ModelPtr_ndwdw_set, doc='\n    Number of nonzero elements in the `w` derivative of the\n    repeating elements\n    ')
    ndxdotdw = property(_amici.ModelPtr_ndxdotdw_get, _amici.ModelPtr_ndxdotdw_set, doc=' Number of nonzero elements in the :math:`w` derivative of :math:`xdot`')
    ndJydy = property(_amici.ModelPtr_ndJydy_get, _amici.ModelPtr_ndJydy_set, doc='\n    Number of nonzero elements in the :math:`y` derivative of\n    :math:`dJy` (dimension `nytrue`)\n    ')
    ndxrdatadxsolver = property(_amici.ModelPtr_ndxrdatadxsolver_get, _amici.ModelPtr_ndxrdatadxsolver_set, doc=' Number of nonzero elements in the :math:`x` derivative of :math:`x_rdata`')
    ndxrdatadtcl = property(_amici.ModelPtr_ndxrdatadtcl_get, _amici.ModelPtr_ndxrdatadtcl_set, doc=' Number of nonzero elements in the :math:`tcl` derivative of :math:`x_rdata`')
    ndtotal_cldx_rdata = property(_amici.ModelPtr_ndtotal_cldx_rdata_get, _amici.ModelPtr_ndtotal_cldx_rdata_set, doc='\n    Number of nonzero elements in the :math:`x_rdata` derivative of\n    :math:`total_cl`\n    ')
    nnz = property(_amici.ModelPtr_nnz_get, _amici.ModelPtr_nnz_set, doc=' Number of nonzero entries in Jacobian')
    nJ = property(_amici.ModelPtr_nJ_get, _amici.ModelPtr_nJ_set, doc=' Dimension of the augmented objective function for 2nd order ASA')
    ubw = property(_amici.ModelPtr_ubw_get, _amici.ModelPtr_ubw_set, doc=' Upper bandwidth of the Jacobian')
    lbw = property(_amici.ModelPtr_lbw_get, _amici.ModelPtr_lbw_set, doc=' Lower bandwidth of the Jacobian')
_amici.ModelPtr_swigregister(ModelPtr)

class ExpDataPtr(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _amici.ExpDataPtr_swiginit(self, _amici.new_ExpDataPtr(*args))

    def __deref__(self):
        return _amici.ExpDataPtr___deref__(self)

    def release(self):
        return _amici.ExpDataPtr_release(self)

    def reset(self, *args):
        return _amici.ExpDataPtr_reset(self, *args)

    def swap(self, __u):
        return _amici.ExpDataPtr_swap(self, __u)

    def get(self):
        return _amici.ExpDataPtr_get(self)

    def __nonzero__(self):
        return _amici.ExpDataPtr___nonzero__(self)
    __bool__ = __nonzero__
    __swig_destroy__ = _amici.delete_ExpDataPtr

    def __repr__(self):
        return _edata_repr(self)

    def nytrue(self) -> int:
        """
        number of observables of the non-augmented model

        :return: number of observables of the non-augmented model
        """
        return _amici.ExpDataPtr_nytrue(self)

    def nztrue(self) -> int:
        """
        number of event observables of the non-augmented model

        :return: number of event observables of the non-augmented model
        """
        return _amici.ExpDataPtr_nztrue(self)

    def nmaxevent(self) -> int:
        """
        maximal number of events to track

        :return: maximal number of events to track
        """
        return _amici.ExpDataPtr_nmaxevent(self)

    def nt(self) -> int:
        """
        number of timepoints

        :return: number of timepoints
        """
        return _amici.ExpDataPtr_nt(self)

    def setTimepoints(self, ts: Sequence[float]):
        """
        Set output timepoints.

        If the number of timepoint increases, this will grow the
        observation/sigma matrices and fill new entries with NaN.
        If the number of timepoints decreases, this will shrink the
        observation/sigma matrices.

        Note that the mapping from timepoints to measurements will not be
        preserved. E.g., say there are measurements at t = 2, and this
        function is called with [1, 2], then the old measurements will belong to
        t = 1.

        :param ts: timepoints
        """
        return _amici.ExpDataPtr_setTimepoints(self, ts)

    def getTimepoints(self) -> Sequence[float]:
        """
        Get output timepoints.

        :return: ExpData::ts
        """
        return _amici.ExpDataPtr_getTimepoints(self)

    def getTimepoint(self, it: int) -> 'float':
        """
        Get timepoint for the given index

        :param it: timepoint index

        :return: timepoint timepoint at index
        """
        return _amici.ExpDataPtr_getTimepoint(self, it)

    def setObservedData(self, *args):
        """
        *Overload 1:*

        Set all measurements.

        :type observedData: DoubleVector
        :param observedData: observed data (dimension: nt x nytrue, row-major)

        |

        *Overload 2:*

        Set measurements for a given observable index

        :type observedData: DoubleVector
        :param observedData: observed data (dimension: nt)
        :type iy: int
        :param iy: observed data index
        """
        return _amici.ExpDataPtr_setObservedData(self, *args)

    def isSetObservedData(self, it: int, iy: int) -> bool:
        """
        Whether there is a measurement for the given time- and observable-
        index.

        :param it: time index
        :param iy: observable index

        :return: boolean specifying if data was set
        """
        return _amici.ExpDataPtr_isSetObservedData(self, it, iy)

    def getObservedData(self) -> Sequence[float]:
        """
        Get all measurements.

        :return: observed data (dimension: nt x nytrue, row-major)
        """
        return _amici.ExpDataPtr_getObservedData(self)

    def getObservedDataPtr(self, it: int) -> 'float':
        """
        Get measurements for a given timepoint index.

        :param it: timepoint index

        :return: pointer to observed data at index (dimension: nytrue)
        """
        return _amici.ExpDataPtr_getObservedDataPtr(self, it)

    def setObservedDataStdDev(self, *args):
        """
        *Overload 1:*

        Set standard deviations for measurements.

        :type observedDataStdDev: DoubleVector
        :param observedDataStdDev: standard deviation of observed data (dimension:
            nt x nytrue, row-major)

        |

        *Overload 2:*

        Set identical standard deviation for all measurements.

        :type stdDev: float
        :param stdDev: standard deviation (dimension: scalar)

        |

        *Overload 3:*

        Set standard deviations of observed data for a
        specific observable index.

        :type observedDataStdDev: DoubleVector
        :param observedDataStdDev: standard deviation of observed data (dimension:
            nt)
        :type iy: int
        :param iy: observed data index

        |

        *Overload 4:*

        Set all standard deviation for a given observable index to the
        input value.

        :type stdDev: float
        :param stdDev: standard deviation (dimension: scalar)
        :type iy: int
        :param iy: observed data index
        """
        return _amici.ExpDataPtr_setObservedDataStdDev(self, *args)

    def isSetObservedDataStdDev(self, it: int, iy: int) -> bool:
        """
        Whether standard deviation for a measurement at
        specified timepoint- and observable index has been set.

        :param it: time index
        :param iy: observable index
        :return: boolean specifying if standard deviation of data was set
        """
        return _amici.ExpDataPtr_isSetObservedDataStdDev(self, it, iy)

    def getObservedDataStdDev(self) -> Sequence[float]:
        """
        Get measurement standard deviations.

        :return: standard deviation of observed data
        """
        return _amici.ExpDataPtr_getObservedDataStdDev(self)

    def getObservedDataStdDevPtr(self, it: int) -> 'float':
        """
        Get pointer to measurement standard deviations.

        :param it: timepoint index
        :return: pointer to standard deviation of observed data at index
        """
        return _amici.ExpDataPtr_getObservedDataStdDevPtr(self, it)

    def setObservedEvents(self, *args):
        """
        *Overload 1:*

        Set observed event data.

        :type observedEvents: DoubleVector
        :param observedEvents: observed data (dimension: nmaxevent x nztrue,
            row-major)

        |

        *Overload 2:*

        Set observed event data for specific event observable.

        :type observedEvents: DoubleVector
        :param observedEvents: observed data (dimension: nmaxevent)
        :type iz: int
        :param iz: observed event data index
        """
        return _amici.ExpDataPtr_setObservedEvents(self, *args)

    def isSetObservedEvents(self, ie: int, iz: int) -> bool:
        """
        Check whether event data at specified indices has been set.

        :param ie: event index
        :param iz: event observable index
        :return: boolean specifying if data was set
        """
        return _amici.ExpDataPtr_isSetObservedEvents(self, ie, iz)

    def getObservedEvents(self) -> Sequence[float]:
        """
        Get observed event data.

        :return: observed event data
        """
        return _amici.ExpDataPtr_getObservedEvents(self)

    def getObservedEventsPtr(self, ie: int) -> 'float':
        """
        Get pointer to observed data at ie-th occurrence.

        :param ie: event occurrence

        :return: pointer to observed event data at ie-th occurrence
        """
        return _amici.ExpDataPtr_getObservedEventsPtr(self, ie)

    def setObservedEventsStdDev(self, *args):
        """
        *Overload 1:*

        Set standard deviation of observed event data.

        :type observedEventsStdDev: DoubleVector
        :param observedEventsStdDev: standard deviation of observed event data

        |

        *Overload 2:*

        Set standard deviation of observed event data.

        :type stdDev: float
        :param stdDev: standard deviation (dimension: scalar)

        |

        *Overload 3:*

        Set standard deviation of observed data for a specific observable.

        :type observedEventsStdDev: DoubleVector
        :param observedEventsStdDev: standard deviation of observed data
            (dimension: nmaxevent)
        :type iz: int
        :param iz: observed data index

        |

        *Overload 4:*

        Set all standard deviations of a specific event-observable.

        :type stdDev: float
        :param stdDev: standard deviation (dimension: scalar)
        :type iz: int
        :param iz: observed data index
        """
        return _amici.ExpDataPtr_setObservedEventsStdDev(self, *args)

    def isSetObservedEventsStdDev(self, ie: int, iz: int) -> bool:
        """
        Check whether standard deviation of event data
        at specified indices has been set.

        :param ie: event index
        :param iz: event observable index
        :return: boolean specifying if standard deviation of event data was set
        """
        return _amici.ExpDataPtr_isSetObservedEventsStdDev(self, ie, iz)

    def getObservedEventsStdDev(self) -> Sequence[float]:
        """
        Get standard deviation of observed event data.

        :return: standard deviation of observed event data
        """
        return _amici.ExpDataPtr_getObservedEventsStdDev(self)

    def getObservedEventsStdDevPtr(self, ie: int) -> 'float':
        """
        Get pointer to standard deviation of
        observed event data at ie-th occurrence.

        :param ie: event occurrence

        :return: pointer to standard deviation of observed event data at ie-th
            occurrence
        """
        return _amici.ExpDataPtr_getObservedEventsStdDevPtr(self, ie)

    def clear_observations(self):
        """
        Set all observations and their standard deviations to NaN.

        Useful, e.g., after calling ExpData::setTimepoints.
        """
        return _amici.ExpDataPtr_clear_observations(self)
    id = property(_amici.ExpDataPtr_id_get, _amici.ExpDataPtr_id_set, doc='Arbitrary (not necessarily unique) identifier.')

    def reinitializeAllFixedParameterDependentInitialStatesForPresimulation(self, nx_rdata: int):
        """
        Set reinitialization of all states based on model constants for
        presimulation (only meaningful if preequilibration is performed).

        Convenience function to populate
        `reinitialization_state_idxs_presim` and
        `reinitialization_state_idxs_sim`

        :param nx_rdata: Number of states (Model::nx_rdata)
        """
        return _amici.ExpDataPtr_reinitializeAllFixedParameterDependentInitialStatesForPresimulation(self, nx_rdata)

    def reinitializeAllFixedParameterDependentInitialStatesForSimulation(self, nx_rdata: int):
        """
        Set reinitialization of all states based on model constants for
        the 'main' simulation (only meaningful if presimulation or
        preequilibration is performed).

        Convenience function to populate
        `reinitialization_state_idxs_presim` and
        `reinitialization_state_idxs_sim`

        :param nx_rdata: Number of states (Model::nx_rdata)
        """
        return _amici.ExpDataPtr_reinitializeAllFixedParameterDependentInitialStatesForSimulation(self, nx_rdata)

    def reinitializeAllFixedParameterDependentInitialStates(self, nx_rdata: int):
        """
        Set reinitialization of all states based on model constants for
        all simulation phases.

        Convenience function to populate
        `reinitialization_state_idxs_presim` and
        `reinitialization_state_idxs_sim`

        :param nx_rdata: Number of states (Model::nx_rdata)
        """
        return _amici.ExpDataPtr_reinitializeAllFixedParameterDependentInitialStates(self, nx_rdata)
    fixedParameters = property(_amici.ExpDataPtr_fixedParameters_get, _amici.ExpDataPtr_fixedParameters_set, doc='\n    Model constants\n\n    Vector of size Model::nk() or empty\n    ')
    fixedParametersPreequilibration = property(_amici.ExpDataPtr_fixedParametersPreequilibration_get, _amici.ExpDataPtr_fixedParametersPreequilibration_set, doc='\n    Model constants for pre-equilibration\n\n    Vector of size Model::nk() or empty.\n    ')
    fixedParametersPresimulation = property(_amici.ExpDataPtr_fixedParametersPresimulation_get, _amici.ExpDataPtr_fixedParametersPresimulation_set, doc='\n    Model constants for pre-simulation\n\n    Vector of size Model::nk() or empty.\n    ')
    parameters = property(_amici.ExpDataPtr_parameters_get, _amici.ExpDataPtr_parameters_set, doc='\n    Model parameters\n\n    Vector of size Model::np() or empty with parameter scaled according to\n    SimulationParameter::pscale.\n    ')
    x0 = property(_amici.ExpDataPtr_x0_get, _amici.ExpDataPtr_x0_set, doc='\n    Initial state\n\n    Vector of size Model::nx() or empty\n    ')
    sx0 = property(_amici.ExpDataPtr_sx0_get, _amici.ExpDataPtr_sx0_set, doc='\n    Initial state sensitivities\n\n    Dimensions:\n    Model::nx() * Model::nplist(), Model::nx() * ExpData::plist.size(), if\n    ExpData::plist is not empty, or empty\n    ')
    pscale = property(_amici.ExpDataPtr_pscale_get, _amici.ExpDataPtr_pscale_set, doc='\n    Parameter scales\n\n    Vector of parameter scale of size Model::np(), indicating how/if each\n    parameter is to be scaled.\n    ')
    plist = property(_amici.ExpDataPtr_plist_get, _amici.ExpDataPtr_plist_set, doc='Parameter indices w.r.t. which to compute sensitivities')
    tstart_ = property(_amici.ExpDataPtr_tstart__get, _amici.ExpDataPtr_tstart__set, doc='\n    Starting time of the simulation.\n\n    Output timepoints are absolute timepoints, independent of\n    :math:`t_{start}`.\n    For output timepoints :math:`t <  t_{start}`, the initial state will be\n    returned.\n    ')
    t_presim = property(_amici.ExpDataPtr_t_presim_get, _amici.ExpDataPtr_t_presim_set, doc='\n    Duration of pre-simulation.\n\n    If this is > 0, presimulation will be performed from\n    (model->t0 - t_presim) to model->t0 using the fixedParameters in\n    fixedParametersPresimulation\n    ')
    ts_ = property(_amici.ExpDataPtr_ts__get, _amici.ExpDataPtr_ts__set, doc='\n    Timepoints for which model state/outputs/... are requested\n\n    Vector of timepoints.\n    ')
    reinitializeFixedParameterInitialStates = property(_amici.ExpDataPtr_reinitializeFixedParameterInitialStates_get, _amici.ExpDataPtr_reinitializeFixedParameterInitialStates_set, doc='\n    Flag indicating whether reinitialization of states depending on\n    fixed parameters is activated\n    ')
    reinitialization_state_idxs_presim = property(_amici.ExpDataPtr_reinitialization_state_idxs_presim_get, _amici.ExpDataPtr_reinitialization_state_idxs_presim_set, doc='\n    Indices of states to be reinitialized based on provided\n    presimulation constants / fixed parameters.\n    ')
    reinitialization_state_idxs_sim = property(_amici.ExpDataPtr_reinitialization_state_idxs_sim_get, _amici.ExpDataPtr_reinitialization_state_idxs_sim_set, doc='\n    Indices of states to be reinitialized based on provided\n    constants / fixed parameters.\n    ')
_amici.ExpDataPtr_swigregister(ExpDataPtr)
M_E = _amici.M_E
M_LOG2E = _amici.M_LOG2E
M_LOG10E = _amici.M_LOG10E
M_LN2 = _amici.M_LN2
M_LN10 = _amici.M_LN10
M_PI = _amici.M_PI
M_PI_2 = _amici.M_PI_2
M_PI_4 = _amici.M_PI_4
M_1_PI = _amici.M_1_PI
M_2_PI = _amici.M_2_PI
M_2_SQRTPI = _amici.M_2_SQRTPI
M_SQRT2 = _amici.M_SQRT2
M_SQRT1_2 = _amici.M_SQRT1_2
BLASLayout_rowMajor = _amici.BLASLayout_rowMajor
BLASLayout_colMajor = _amici.BLASLayout_colMajor
BLASTranspose_noTrans = _amici.BLASTranspose_noTrans
BLASTranspose_trans = _amici.BLASTranspose_trans
BLASTranspose_conjTrans = _amici.BLASTranspose_conjTrans
ParameterScaling_none = _amici.ParameterScaling_none
ParameterScaling_ln = _amici.ParameterScaling_ln
ParameterScaling_log10 = _amici.ParameterScaling_log10
ObservableScaling_lin = _amici.ObservableScaling_lin
ObservableScaling_log = _amici.ObservableScaling_log
ObservableScaling_log10 = _amici.ObservableScaling_log10
SecondOrderMode_none = _amici.SecondOrderMode_none
SecondOrderMode_full = _amici.SecondOrderMode_full
SecondOrderMode_directional = _amici.SecondOrderMode_directional
SensitivityOrder_none = _amici.SensitivityOrder_none
" Don't compute sensitivities."
SensitivityOrder_first = _amici.SensitivityOrder_first
' First-order sensitivities.'
SensitivityOrder_second = _amici.SensitivityOrder_second
' Second-order sensitivities.'
SensitivityMethod_none = _amici.SensitivityMethod_none
" Don't compute sensitivities."
SensitivityMethod_forward = _amici.SensitivityMethod_forward
' Forward sensitivity analysis.'
SensitivityMethod_adjoint = _amici.SensitivityMethod_adjoint
' Adjoint sensitivity analysis.'
LinearSolver_dense = _amici.LinearSolver_dense
LinearSolver_band = _amici.LinearSolver_band
LinearSolver_LAPACKDense = _amici.LinearSolver_LAPACKDense
LinearSolver_LAPACKBand = _amici.LinearSolver_LAPACKBand
LinearSolver_diag = _amici.LinearSolver_diag
LinearSolver_SPGMR = _amici.LinearSolver_SPGMR
LinearSolver_SPBCG = _amici.LinearSolver_SPBCG
LinearSolver_SPTFQMR = _amici.LinearSolver_SPTFQMR
LinearSolver_KLU = _amici.LinearSolver_KLU
LinearSolver_SuperLUMT = _amici.LinearSolver_SuperLUMT
InternalSensitivityMethod_simultaneous = _amici.InternalSensitivityMethod_simultaneous
InternalSensitivityMethod_staggered = _amici.InternalSensitivityMethod_staggered
InternalSensitivityMethod_staggered1 = _amici.InternalSensitivityMethod_staggered1
InterpolationType_hermite = _amici.InterpolationType_hermite
InterpolationType_polynomial = _amici.InterpolationType_polynomial
LinearMultistepMethod_adams = _amici.LinearMultistepMethod_adams
LinearMultistepMethod_BDF = _amici.LinearMultistepMethod_BDF
NonlinearSolverIteration_functional = _amici.NonlinearSolverIteration_functional
NonlinearSolverIteration_fixedpoint = _amici.NonlinearSolverIteration_fixedpoint
' deprecated'
NonlinearSolverIteration_newton = _amici.NonlinearSolverIteration_newton
SteadyStateComputationMode_newtonOnly = _amici.SteadyStateComputationMode_newtonOnly
SteadyStateComputationMode_integrationOnly = _amici.SteadyStateComputationMode_integrationOnly
SteadyStateComputationMode_integrateIfNewtonFails = _amici.SteadyStateComputationMode_integrateIfNewtonFails
SteadyStateSensitivityMode_newtonOnly = _amici.SteadyStateSensitivityMode_newtonOnly
SteadyStateSensitivityMode_integrationOnly = _amici.SteadyStateSensitivityMode_integrationOnly
SteadyStateSensitivityMode_integrateIfNewtonFails = _amici.SteadyStateSensitivityMode_integrateIfNewtonFails
SteadyStateStatus_failed_too_long_simulation = _amici.SteadyStateStatus_failed_too_long_simulation
SteadyStateStatus_failed_damping = _amici.SteadyStateStatus_failed_damping
SteadyStateStatus_failed_factorization = _amici.SteadyStateStatus_failed_factorization
SteadyStateStatus_failed_convergence = _amici.SteadyStateStatus_failed_convergence
SteadyStateStatus_failed = _amici.SteadyStateStatus_failed
SteadyStateStatus_not_run = _amici.SteadyStateStatus_not_run
SteadyStateStatus_success = _amici.SteadyStateStatus_success
SteadyStateContext_newtonSensi = _amici.SteadyStateContext_newtonSensi
SteadyStateContext_sensiStorage = _amici.SteadyStateContext_sensiStorage
SteadyStateContext_solverCreation = _amici.SteadyStateContext_solverCreation
NewtonDampingFactorMode_off = _amici.NewtonDampingFactorMode_off
NewtonDampingFactorMode_on = _amici.NewtonDampingFactorMode_on
FixedParameterContext_simulation = _amici.FixedParameterContext_simulation
FixedParameterContext_preequilibration = _amici.FixedParameterContext_preequilibration
FixedParameterContext_presimulation = _amici.FixedParameterContext_presimulation
RDataReporting_full = _amici.RDataReporting_full
RDataReporting_residuals = _amici.RDataReporting_residuals
RDataReporting_likelihood = _amici.RDataReporting_likelihood
SplineBoundaryCondition_given = _amici.SplineBoundaryCondition_given
SplineBoundaryCondition_zeroDerivative = _amici.SplineBoundaryCondition_zeroDerivative
SplineBoundaryCondition_natural = _amici.SplineBoundaryCondition_natural
SplineBoundaryCondition_naturalZeroDerivative = _amici.SplineBoundaryCondition_naturalZeroDerivative
SplineBoundaryCondition_periodic = _amici.SplineBoundaryCondition_periodic
SplineExtrapolation_noExtrapolation = _amici.SplineExtrapolation_noExtrapolation
SplineExtrapolation_constant = _amici.SplineExtrapolation_constant
SplineExtrapolation_linear = _amici.SplineExtrapolation_linear
SplineExtrapolation_polynomial = _amici.SplineExtrapolation_polynomial
SplineExtrapolation_periodic = _amici.SplineExtrapolation_periodic
Constraint_none = _amici.Constraint_none
Constraint_non_negative = _amici.Constraint_non_negative
Constraint_non_positive = _amici.Constraint_non_positive
Constraint_positive = _amici.Constraint_positive
Constraint_negative = _amici.Constraint_negative

class ModelDimensions(object):
    """
    Container for model dimensions.

    Holds number of states, observables, etc.
    """
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        *Overload 1:*
         Default ctor

        |

        *Overload 2:*

        Constructor with model dimensions
        :type nx_rdata: int
        :param nx_rdata: Number of state variables
        :type nxtrue_rdata: int
        :param nxtrue_rdata: Number of state variables of the non-augmented model
        :type nx_solver: int
        :param nx_solver: Number of state variables with conservation laws applied
        :type nxtrue_solver: int
        :param nxtrue_solver: Number of state variables of the non-augmented model
            with conservation laws applied
        :type nx_solver_reinit: int
        :param nx_solver_reinit: Number of state variables with conservation laws
            subject to reinitialization
        :type np: int
        :param np: Number of parameters
        :type nk: int
        :param nk: Number of constants
        :type ny: int
        :param ny: Number of observables
        :type nytrue: int
        :param nytrue: Number of observables of the non-augmented model
        :type nz: int
        :param nz: Number of event observables
        :type nztrue: int
        :param nztrue: Number of event observables of the non-augmented model
        :type ne: int
        :param ne: Number of events
        :type ne_solver: int
        :param ne_solver: Number of events that require root-finding
        :type nspl: int
        :param nspl: Number of splines
        :type nJ: int
        :param nJ: Number of objective functions
        :type nw: int
        :param nw: Number of repeating elements
        :type ndwdx: int
        :param ndwdx: Number of nonzero elements in the `x` derivative of the
            repeating elements
        :type ndwdp: int
        :param ndwdp: Number of nonzero elements in the `p` derivative of the
            repeating elements
        :type ndwdw: int
        :param ndwdw: Number of nonzero elements in the `w` derivative of the
            repeating elements
        :type ndxdotdw: int
        :param ndxdotdw: Number of nonzero elements in the :math:`w` derivative of
            :math:`xdot`
        :type ndJydy: IntVector
        :param ndJydy: Number of nonzero elements in the :math:`y` derivative of
            :math:`dJy` (shape `nytrue`)
        :type ndxrdatadxsolver: int
        :param ndxrdatadxsolver: Number of nonzero elements in the :math:`x`
            derivative of :math:`x_rdata`
        :type ndxrdatadtcl: int
        :param ndxrdatadtcl: Number of nonzero elements in the :math:`tcl`
            derivative of :math:`x_rdata`
        :type ndtotal_cldx_rdata: int
        :param ndtotal_cldx_rdata: Number of nonzero elements in the
            :math:`x_rdata`  derivative of :math:`total_cl`
        :type nnz: int
        :param nnz: Number of nonzero elements in Jacobian
        :type ubw: int
        :param ubw: Upper matrix bandwidth in the Jacobian
        :type lbw: int
        :param lbw: Lower matrix bandwidth in the Jacobian
        """
        _amici.ModelDimensions_swiginit(self, _amici.new_ModelDimensions(*args))
    nx_rdata = property(_amici.ModelDimensions_nx_rdata_get, _amici.ModelDimensions_nx_rdata_set, doc=' Number of states')
    nxtrue_rdata = property(_amici.ModelDimensions_nxtrue_rdata_get, _amici.ModelDimensions_nxtrue_rdata_set, doc=' Number of states in the unaugmented system')
    nx_solver = property(_amici.ModelDimensions_nx_solver_get, _amici.ModelDimensions_nx_solver_set, doc=' Number of states with conservation laws applied')
    nxtrue_solver = property(_amici.ModelDimensions_nxtrue_solver_get, _amici.ModelDimensions_nxtrue_solver_set, doc='\n    Number of states in the unaugmented system with conservation laws\n    applied\n    ')
    nx_solver_reinit = property(_amici.ModelDimensions_nx_solver_reinit_get, _amici.ModelDimensions_nx_solver_reinit_set, doc=' Number of solver states subject to reinitialization')
    np = property(_amici.ModelDimensions_np_get, _amici.ModelDimensions_np_set, doc=' Number of parameters')
    nk = property(_amici.ModelDimensions_nk_get, _amici.ModelDimensions_nk_set, doc=' Number of constants')
    ny = property(_amici.ModelDimensions_ny_get, _amici.ModelDimensions_ny_set, doc=' Number of observables')
    nytrue = property(_amici.ModelDimensions_nytrue_get, _amici.ModelDimensions_nytrue_set, doc=' Number of observables in the unaugmented system')
    nz = property(_amici.ModelDimensions_nz_get, _amici.ModelDimensions_nz_set, doc=' Number of event outputs')
    nztrue = property(_amici.ModelDimensions_nztrue_get, _amici.ModelDimensions_nztrue_set, doc=' Number of event outputs in the unaugmented system')
    ne = property(_amici.ModelDimensions_ne_get, _amici.ModelDimensions_ne_set, doc=' Number of events')
    ne_solver = property(_amici.ModelDimensions_ne_solver_get, _amici.ModelDimensions_ne_solver_set, doc=' Number of events that require root-finding')
    nspl = property(_amici.ModelDimensions_nspl_get, _amici.ModelDimensions_nspl_set, doc=' Number of spline functions in the model')
    nw = property(_amici.ModelDimensions_nw_get, _amici.ModelDimensions_nw_set, doc=' Number of common expressions')
    ndwdx = property(_amici.ModelDimensions_ndwdx_get, _amici.ModelDimensions_ndwdx_set, doc='\n    Number of nonzero elements in the `x` derivative of the\n    repeating elements\n    ')
    ndwdp = property(_amici.ModelDimensions_ndwdp_get, _amici.ModelDimensions_ndwdp_set, doc='\n    Number of nonzero elements in the `p` derivative of the\n    repeating elements\n    ')
    ndwdw = property(_amici.ModelDimensions_ndwdw_get, _amici.ModelDimensions_ndwdw_set, doc='\n    Number of nonzero elements in the `w` derivative of the\n    repeating elements\n    ')
    ndxdotdw = property(_amici.ModelDimensions_ndxdotdw_get, _amici.ModelDimensions_ndxdotdw_set, doc=' Number of nonzero elements in the :math:`w` derivative of :math:`xdot`')
    ndJydy = property(_amici.ModelDimensions_ndJydy_get, _amici.ModelDimensions_ndJydy_set, doc='\n    Number of nonzero elements in the :math:`y` derivative of\n    :math:`dJy` (dimension `nytrue`)\n    ')
    ndxrdatadxsolver = property(_amici.ModelDimensions_ndxrdatadxsolver_get, _amici.ModelDimensions_ndxrdatadxsolver_set, doc=' Number of nonzero elements in the :math:`x` derivative of :math:`x_rdata`')
    ndxrdatadtcl = property(_amici.ModelDimensions_ndxrdatadtcl_get, _amici.ModelDimensions_ndxrdatadtcl_set, doc=' Number of nonzero elements in the :math:`tcl` derivative of :math:`x_rdata`')
    ndtotal_cldx_rdata = property(_amici.ModelDimensions_ndtotal_cldx_rdata_get, _amici.ModelDimensions_ndtotal_cldx_rdata_set, doc='\n    Number of nonzero elements in the :math:`x_rdata` derivative of\n    :math:`total_cl`\n    ')
    nnz = property(_amici.ModelDimensions_nnz_get, _amici.ModelDimensions_nnz_set, doc=' Number of nonzero entries in Jacobian')
    nJ = property(_amici.ModelDimensions_nJ_get, _amici.ModelDimensions_nJ_set, doc=' Dimension of the augmented objective function for 2nd order ASA')
    ubw = property(_amici.ModelDimensions_ubw_get, _amici.ModelDimensions_ubw_set, doc=' Upper bandwidth of the Jacobian')
    lbw = property(_amici.ModelDimensions_lbw_get, _amici.ModelDimensions_lbw_set, doc=' Lower bandwidth of the Jacobian')
    __swig_destroy__ = _amici.delete_ModelDimensions
_amici.ModelDimensions_swigregister(ModelDimensions)
cvar = _amici.cvar
pi = cvar.pi
AMICI_ONEOUTPUT = cvar.AMICI_ONEOUTPUT
AMICI_RECOVERABLE_ERROR = cvar.AMICI_RECOVERABLE_ERROR
AMICI_UNRECOVERABLE_ERROR = cvar.AMICI_UNRECOVERABLE_ERROR
AMICI_TOO_MUCH_WORK = cvar.AMICI_TOO_MUCH_WORK
AMICI_TOO_MUCH_ACC = cvar.AMICI_TOO_MUCH_ACC
AMICI_ERR_FAILURE = cvar.AMICI_ERR_FAILURE
AMICI_CONV_FAILURE = cvar.AMICI_CONV_FAILURE
AMICI_LSETUP_FAIL = cvar.AMICI_LSETUP_FAIL
AMICI_RHSFUNC_FAIL = cvar.AMICI_RHSFUNC_FAIL
AMICI_FIRST_RHSFUNC_ERR = cvar.AMICI_FIRST_RHSFUNC_ERR
AMICI_CONSTR_FAIL = cvar.AMICI_CONSTR_FAIL
AMICI_ILL_INPUT = cvar.AMICI_ILL_INPUT
AMICI_ERROR = cvar.AMICI_ERROR
AMICI_NO_STEADY_STATE = cvar.AMICI_NO_STEADY_STATE
AMICI_DAMPING_FACTOR_ERROR = cvar.AMICI_DAMPING_FACTOR_ERROR
AMICI_SINGULAR_JACOBIAN = cvar.AMICI_SINGULAR_JACOBIAN
AMICI_NOT_IMPLEMENTED = cvar.AMICI_NOT_IMPLEMENTED
AMICI_MAX_TIME_EXCEEDED = cvar.AMICI_MAX_TIME_EXCEEDED
AMICI_NOT_RUN = cvar.AMICI_NOT_RUN
AMICI_SUCCESS = cvar.AMICI_SUCCESS
AMICI_DATA_RETURN = cvar.AMICI_DATA_RETURN
AMICI_ROOT_RETURN = cvar.AMICI_ROOT_RETURN
AMICI_NORMAL = cvar.AMICI_NORMAL
AMICI_ONE_STEP = cvar.AMICI_ONE_STEP
AMICI_PREEQUILIBRATE = cvar.AMICI_PREEQUILIBRATE

class SimulationParameters(object):
    """Container for various simulation parameters."""
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        *Overload 1:*

        Constructor
        :type timepoints: DoubleVector
        :param timepoints: Timepoints for which simulation results are requested

        |

        *Overload 2:*

        Constructor
        :type fixedParameters: DoubleVector
        :param fixedParameters: Model constants
        :type parameters: DoubleVector
        :param parameters: Model parameters
        """
        _amici.SimulationParameters_swiginit(self, _amici.new_SimulationParameters(*args))

    def reinitializeAllFixedParameterDependentInitialStatesForPresimulation(self, nx_rdata: int):
        """
        Set reinitialization of all states based on model constants for
        presimulation (only meaningful if preequilibration is performed).

        Convenience function to populate
        `reinitialization_state_idxs_presim` and
        `reinitialization_state_idxs_sim`

        :param nx_rdata: Number of states (Model::nx_rdata)
        """
        return _amici.SimulationParameters_reinitializeAllFixedParameterDependentInitialStatesForPresimulation(self, nx_rdata)

    def reinitializeAllFixedParameterDependentInitialStatesForSimulation(self, nx_rdata: int):
        """
        Set reinitialization of all states based on model constants for
        the 'main' simulation (only meaningful if presimulation or
        preequilibration is performed).

        Convenience function to populate
        `reinitialization_state_idxs_presim` and
        `reinitialization_state_idxs_sim`

        :param nx_rdata: Number of states (Model::nx_rdata)
        """
        return _amici.SimulationParameters_reinitializeAllFixedParameterDependentInitialStatesForSimulation(self, nx_rdata)

    def reinitializeAllFixedParameterDependentInitialStates(self, nx_rdata: int):
        """
        Set reinitialization of all states based on model constants for
        all simulation phases.

        Convenience function to populate
        `reinitialization_state_idxs_presim` and
        `reinitialization_state_idxs_sim`

        :param nx_rdata: Number of states (Model::nx_rdata)
        """
        return _amici.SimulationParameters_reinitializeAllFixedParameterDependentInitialStates(self, nx_rdata)
    fixedParameters = property(_amici.SimulationParameters_fixedParameters_get, _amici.SimulationParameters_fixedParameters_set, doc='\n    Model constants\n\n    Vector of size Model::nk() or empty\n    ')
    fixedParametersPreequilibration = property(_amici.SimulationParameters_fixedParametersPreequilibration_get, _amici.SimulationParameters_fixedParametersPreequilibration_set, doc='\n    Model constants for pre-equilibration\n\n    Vector of size Model::nk() or empty.\n    ')
    fixedParametersPresimulation = property(_amici.SimulationParameters_fixedParametersPresimulation_get, _amici.SimulationParameters_fixedParametersPresimulation_set, doc='\n    Model constants for pre-simulation\n\n    Vector of size Model::nk() or empty.\n    ')
    parameters = property(_amici.SimulationParameters_parameters_get, _amici.SimulationParameters_parameters_set, doc='\n    Model parameters\n\n    Vector of size Model::np() or empty with parameter scaled according to\n    SimulationParameter::pscale.\n    ')
    x0 = property(_amici.SimulationParameters_x0_get, _amici.SimulationParameters_x0_set, doc='\n    Initial state\n\n    Vector of size Model::nx() or empty\n    ')
    sx0 = property(_amici.SimulationParameters_sx0_get, _amici.SimulationParameters_sx0_set, doc='\n    Initial state sensitivities\n\n    Dimensions:\n    Model::nx() * Model::nplist(), Model::nx() * ExpData::plist.size(), if\n    ExpData::plist is not empty, or empty\n    ')
    pscale = property(_amici.SimulationParameters_pscale_get, _amici.SimulationParameters_pscale_set, doc='\n    Parameter scales\n\n    Vector of parameter scale of size Model::np(), indicating how/if each\n    parameter is to be scaled.\n    ')
    plist = property(_amici.SimulationParameters_plist_get, _amici.SimulationParameters_plist_set, doc='Parameter indices w.r.t. which to compute sensitivities')
    tstart_ = property(_amici.SimulationParameters_tstart__get, _amici.SimulationParameters_tstart__set, doc='\n    Starting time of the simulation.\n\n    Output timepoints are absolute timepoints, independent of\n    :math:`t_{start}`.\n    For output timepoints :math:`t <  t_{start}`, the initial state will be\n    returned.\n    ')
    t_presim = property(_amici.SimulationParameters_t_presim_get, _amici.SimulationParameters_t_presim_set, doc='\n    Duration of pre-simulation.\n\n    If this is > 0, presimulation will be performed from\n    (model->t0 - t_presim) to model->t0 using the fixedParameters in\n    fixedParametersPresimulation\n    ')
    ts_ = property(_amici.SimulationParameters_ts__get, _amici.SimulationParameters_ts__set, doc='\n    Timepoints for which model state/outputs/... are requested\n\n    Vector of timepoints.\n    ')
    reinitializeFixedParameterInitialStates = property(_amici.SimulationParameters_reinitializeFixedParameterInitialStates_get, _amici.SimulationParameters_reinitializeFixedParameterInitialStates_set, doc='\n    Flag indicating whether reinitialization of states depending on\n    fixed parameters is activated\n    ')
    reinitialization_state_idxs_presim = property(_amici.SimulationParameters_reinitialization_state_idxs_presim_get, _amici.SimulationParameters_reinitialization_state_idxs_presim_set, doc='\n    Indices of states to be reinitialized based on provided\n    presimulation constants / fixed parameters.\n    ')
    reinitialization_state_idxs_sim = property(_amici.SimulationParameters_reinitialization_state_idxs_sim_get, _amici.SimulationParameters_reinitialization_state_idxs_sim_set, doc='\n    Indices of states to be reinitialized based on provided\n    constants / fixed parameters.\n    ')
    __swig_destroy__ = _amici.delete_SimulationParameters
_amici.SimulationParameters_swigregister(SimulationParameters)

class AbstractModel(object):
    """
    Abstract base class of amici::Model defining functions that need to
    be implemented in an AMICI model.

    Some functions have empty default implementations or throw.
    This class shall not have any data members.
    """
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError('No constructor defined - class is abstract')
    __repr__ = _swig_repr
    __swig_destroy__ = _amici.delete_AbstractModel

    def getSolver(self) -> 'Solver':
        """
        Retrieves the solver object
        :return: The Solver instance
        """
        return _amici.AbstractModel_getSolver(self)

    def getAmiciVersion(self) -> 'str':
        """
        Returns the AMICI version that was used to generate the model
        :return: AMICI version string
        """
        return _amici.AbstractModel_getAmiciVersion(self)

    def getAmiciCommit(self) -> 'str':
        """
        Returns the AMICI commit that was used to generate the model
        :return: AMICI commit string
        """
        return _amici.AbstractModel_getAmiciCommit(self)

    def isFixedParameterStateReinitializationAllowed(self) -> bool:
        """
        Function indicating whether reinitialization of states depending
        on fixed parameters is permissible
        :return: flag indicating whether reinitialization of states depending on
            fixed parameters is permissible
        """
        return _amici.AbstractModel_isFixedParameterStateReinitializationAllowed(self)

    def fdsigmaydy(self, dsigmaydy: 'float', t: 'float', p: 'float', k: 'float', y: 'float'):
        """
        Model-specific implementation of fsigmay
        :param dsigmaydy: partial derivative of standard deviation of measurements
            w.r.t. model outputs
        :param t: current time
        :param p: parameter vector
        :param k: constant vector
        :param y: model output at timepoint t
        """
        return _amici.AbstractModel_fdsigmaydy(self, dsigmaydy, t, p, k, y)

    def fdx_rdatadx_solver(self, dx_rdatadx_solver: 'float', x: 'float', tcl: 'float', p: 'float', k: 'float'):
        """
        Compute dx_rdata / dx_solver
        :param dx_rdatadx_solver: dx_rdata / dx_solver
        :param p: parameter vector
        :param k: constant vector
        :param x: State variables with conservation laws applied
        :param tcl: Total abundances for conservation laws
        """
        return _amici.AbstractModel_fdx_rdatadx_solver(self, dx_rdatadx_solver, x, tcl, p, k)

    def fdx_rdatadp(self, dx_rdatadp: 'float', x: 'float', tcl: 'float', p: 'float', k: 'float', ip: int):
        """
        Compute dx_rdata / dp
        :param dx_rdatadp: dx_rdata / dp
        :param p: parameter vector
        :param k: constant vector
        :param x: State variables with conservation laws applied
        :param tcl: Total abundances for conservation laws
        :param ip: Sensitivity index
        """
        return _amici.AbstractModel_fdx_rdatadp(self, dx_rdatadp, x, tcl, p, k, ip)

    def fdx_rdatadtcl(self, dx_rdatadtcl: 'float', x: 'float', tcl: 'float', p: 'float', k: 'float'):
        """
        Compute dx_rdata / dtcl
        :param dx_rdatadtcl: dx_rdata / dtcl
        :param p: parameter vector
        :param k: constant vector
        :param x: State variables with conservation laws applied
        :param tcl: Total abundances for conservation laws
        """
        return _amici.AbstractModel_fdx_rdatadtcl(self, dx_rdatadtcl, x, tcl, p, k)

    def fdtotal_cldp(self, dtotal_cldp: 'float', x_rdata: 'float', p: 'float', k: 'float', ip: int):
        """
        Compute dtotal_cl / dp
        :param dtotal_cldp: dtotal_cl / dp
        :param x_rdata: State variables with conservation laws applied
        :param p: parameter vector
        :param k: constant vector
        :param ip: Sensitivity index
        """
        return _amici.AbstractModel_fdtotal_cldp(self, dtotal_cldp, x_rdata, p, k, ip)

    def fdtotal_cldx_rdata(self, dtotal_cldx_rdata: 'float', x_rdata: 'float', p: 'float', k: 'float', tcl: 'float'):
        """
        Compute dtotal_cl / dx_rdata
        :param dtotal_cldx_rdata: dtotal_cl / dx_rdata
        :param x_rdata: State variables with conservation laws applied
        :param p: parameter vector
        :param k: constant vector
        :param tcl: Total abundances for conservation laws
        """
        return _amici.AbstractModel_fdtotal_cldx_rdata(self, dtotal_cldx_rdata, x_rdata, p, k, tcl)

    def fdspline_valuesdp(self, dspline_valuesdp: 'float', p: 'float', k: 'float', ip: int):
        """
        Model-specific implementation the parametric derivatives
        of spline node values
        :param dspline_valuesdp: vector to which derivatives will be written
        :param p: parameter vector
        :param k: constants vector
        :param ip: Sensitivity index
        """
        return _amici.AbstractModel_fdspline_valuesdp(self, dspline_valuesdp, p, k, ip)

    def fdspline_slopesdp(self, dspline_slopesdp: 'float', p: 'float', k: 'float', ip: int):
        """
        Model-specific implementation the parametric derivatives
        of slopevalues at spline nodes
        :param dspline_slopesdp: vector to which derivatives will be written
        :param p: parameter vector
        :param k: constants vector
        :param ip: Sensitivity index
        """
        return _amici.AbstractModel_fdspline_slopesdp(self, dspline_slopesdp, p, k, ip)
_amici.AbstractModel_swigregister(AbstractModel)

def getUnscaledParameter(scaledParameter: 'float', scaling: int) -> 'float':
    """
    Remove parameter scaling according to `scaling`

    :param scaledParameter: scaled parameter
    :param scaling: parameter scaling

    :return: Unscaled parameter
    """
    return _amici.getUnscaledParameter(scaledParameter, scaling)

def getScaledParameter(unscaledParameter: 'float', scaling: int) -> 'float':
    """
    Apply parameter scaling according to `scaling`
    :param unscaledParameter:
    :param scaling: parameter scaling
    :return: Scaled parameter
    """
    return _amici.getScaledParameter(unscaledParameter, scaling)

class CpuTimer(object):
    """ Tracks elapsed CPU time using std::clock."""
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self):
        """Constructor"""
        _amici.CpuTimer_swiginit(self, _amici.new_CpuTimer())

    def reset(self):
        """Reset the timer"""
        return _amici.CpuTimer_reset(self)

    def elapsed_seconds(self) -> 'float':
        """
        Get elapsed CPU time in seconds since initialization or last reset
        :return: CPU time in seconds
        """
        return _amici.CpuTimer_elapsed_seconds(self)

    def elapsed_milliseconds(self) -> 'float':
        """
        Get elapsed CPU time in milliseconds since initialization or last
        reset
        :return: CPU time in milliseconds
        """
        return _amici.CpuTimer_elapsed_milliseconds(self)
    uses_thread_clock = _amici.CpuTimer_uses_thread_clock
    '\n    Whether the timer uses a thread clock (i.e. provides proper,\n    thread-specific CPU time).\n    '
    __swig_destroy__ = _amici.delete_CpuTimer
_amici.CpuTimer_swigregister(CpuTimer)

def _edata_repr(self: 'ExpData'):
    n_data_y = sum((self.isSetObservedData(it, iy) for it in range(self.nt()) for iy in range(self.nytrue())))
    n_sigma_y = sum((self.isSetObservedDataStdDev(it, iy) for it in range(self.nt()) for iy in range(self.nytrue())))
    n_data_z = sum((self.isSetObservedEvents(ie, iz) for ie in range(self.nmaxevent()) for iz in range(self.nztrue())))
    n_sigma_z = sum((self.isSetObservedEventsStdDev(ie, iz) for ie in range(self.nmaxevent()) for iz in range(self.nztrue())))
    custom_simulation_settings = []
    if self.pscale:
        custom_simulation_settings.append(f'parameter scales')
    if self.fixedParameters:
        custom_simulation_settings.append(f'constants')
    if self.fixedParametersPreequilibration:
        custom_simulation_settings.append(f'pre-equilibration condition')
    if self.t_presim:
        tmp = f'pre-simulation condition (t={self.t_presim})'
        if self.fixedParametersPresimulation:
            tmp += ' with custom constants'
        custom_simulation_settings.append(tmp)
    if self.reinitializeFixedParameterInitialStates and self.reinitialization_state_idxs_sim:
        custom_simulation_settings.append(f'{len(self.reinitialization_state_idxs_sim)} reinitialized states (simulation)')
    if self.reinitializeFixedParameterInitialStates and self.reinitialization_state_idxs_presim:
        custom_simulation_settings.append(f'{len(self.reinitialization_state_idxs_presim)} reinitialized states (presimulation)')
    if self.parameters:
        custom_simulation_settings.append(f'parameters')
    if self.x0:
        custom_simulation_settings.append(f'initial states')
    if self.sx0:
        custom_simulation_settings.append(f'initial state sensitivities')
    if custom_simulation_settings:
        custom_simulation_settings = ' with custom ' + ', '.join(custom_simulation_settings)
    else:
        custom_simulation_settings = ' without custom settings'
    return '\n'.join([self.this.__repr__()[:-1], f"  condition '{self.id}' starting at t={self.tstart_}" + custom_simulation_settings, f'  {self.nt()}x{self.nytrue()} time-resolved datapoints', f'    ({n_data_y}/{self.nt() * self.nytrue()} measurements & {n_sigma_y}/{self.nt() * self.nytrue()} sigmas set)', f'  {self.nmaxevent()}x{self.nztrue()} event-resolved datapoints', f'    ({n_data_z}/{self.nmaxevent() * self.nztrue()} measurements & {n_sigma_z}/{self.nmaxevent() * self.nztrue()} sigmas set)', '>'])

class ExpData(SimulationParameters):
    """
    ExpData carries all information about experimental or
    condition-specific data.
    """
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        *Overload 1:*

        Default constructor.

        |

        *Overload 2:*

        Copy constructor.

        |

        *Overload 3:*

        Constructor that only initializes dimensions.

        :type nytrue: int
        :param nytrue: Number of observables
        :type nztrue: int
        :param nztrue: Number of event outputs
        :type nmaxevent: int
        :param nmaxevent: Maximal number of events to track

        |

        *Overload 4:*

        constructor that initializes timepoints from vectors

        :type nytrue: int
        :param nytrue: Number of observables
        :type nztrue: int
        :param nztrue: Number of event outputs
        :type nmaxevent: int
        :param nmaxevent: Maximal number of events to track
        :type ts: DoubleVector
        :param ts: Timepoints (dimension: nt)

        |

        *Overload 5:*

        constructor that initializes timepoints and fixed parameters from
        vectors

        :type nytrue: int
        :param nytrue: Number of observables
        :type nztrue: int
        :param nztrue: Number of event outputs
        :type nmaxevent: int
        :param nmaxevent: Maximal number of events to track
        :type ts: DoubleVector
        :param ts: Timepoints (dimension: nt)
        :type fixedParameters: DoubleVector
        :param fixedParameters: Model constants (dimension: nk)

        |

        *Overload 6:*

        constructor that initializes timepoints and data from vectors

        :type nytrue: int
        :param nytrue: Number of observables
        :type nztrue: int
        :param nztrue: Number of event outputs
        :type nmaxevent: int
        :param nmaxevent: Maximal number of events to track
        :type ts: DoubleVector
        :param ts: Timepoints (dimension: nt)
        :type observedData: DoubleVector
        :param observedData: observed data (dimension: nt x nytrue, row-major)
        :type observedDataStdDev: DoubleVector
        :param observedDataStdDev: standard deviation of observed data
            (dimension: nt x nytrue, row-major)
        :type observedEvents: DoubleVector
        :param observedEvents: observed events
            (dimension: nmaxevents x nztrue, row-major)
        :type observedEventsStdDev: DoubleVector
        :param observedEventsStdDev: standard deviation of observed events/roots
            (dimension: nmaxevents x nztrue, row-major)

        |

        *Overload 7:*

        constructor that initializes with Model

        :type model: :py:class:`Model`
        :param model: pointer to model specification object

        |

        *Overload 8:*

        constructor that initializes with returnData, adds noise according
        to specified sigmas

        :type rdata: :py:class:`ReturnData`
        :param rdata: return data pointer with stored simulation results
        :type sigma_y: float
        :param sigma_y: scalar standard deviations for all observables
        :type sigma_z: float
        :param sigma_z: scalar standard deviations for all event observables

        |

        *Overload 9:*

        constructor that initializes with returnData, adds noise according
        to specified sigmas

        :type rdata: :py:class:`ReturnData`
        :param rdata: return data pointer with stored simulation results
        :type sigma_y: DoubleVector
        :param sigma_y: vector of standard deviations for observables
            (dimension: nytrue or nt x nytrue, row-major)
        :type sigma_z: DoubleVector
        :param sigma_z: vector of standard deviations for event observables
            (dimension: nztrue or nmaxevent x nztrue, row-major)
        """
        '\n        Convenience wrapper for :py:class:`amici.amici.ExpData` constructors\n\n        :param args: arguments\n\n        :returns: ExpData Instance\n        '
        if args:
            from amici.numpy import ReturnDataView
            if isinstance(args[0], (ExpData, ExpDataPtr, Model, ModelPtr)):
                args = (_get_ptr(args[0]), *args[1:])
            elif isinstance(args[0], ReturnDataView):
                args = (_get_ptr(args[0]['ptr']), *args[1:])
        _amici.ExpData_swiginit(self, _amici.new_ExpData(*args))
    __swig_destroy__ = _amici.delete_ExpData

    def nytrue(self) -> int:
        """
        number of observables of the non-augmented model

        :return: number of observables of the non-augmented model
        """
        return _amici.ExpData_nytrue(self)

    def nztrue(self) -> int:
        """
        number of event observables of the non-augmented model

        :return: number of event observables of the non-augmented model
        """
        return _amici.ExpData_nztrue(self)

    def nmaxevent(self) -> int:
        """
        maximal number of events to track

        :return: maximal number of events to track
        """
        return _amici.ExpData_nmaxevent(self)

    def nt(self) -> int:
        """
        number of timepoints

        :return: number of timepoints
        """
        return _amici.ExpData_nt(self)

    def setTimepoints(self, ts: Sequence[float]):
        """
        Set output timepoints.

        If the number of timepoint increases, this will grow the
        observation/sigma matrices and fill new entries with NaN.
        If the number of timepoints decreases, this will shrink the
        observation/sigma matrices.

        Note that the mapping from timepoints to measurements will not be
        preserved. E.g., say there are measurements at t = 2, and this
        function is called with [1, 2], then the old measurements will belong to
        t = 1.

        :param ts: timepoints
        """
        return _amici.ExpData_setTimepoints(self, ts)

    def getTimepoints(self) -> Sequence[float]:
        """
        Get output timepoints.

        :return: ExpData::ts
        """
        return _amici.ExpData_getTimepoints(self)

    def getTimepoint(self, it: int) -> 'float':
        """
        Get timepoint for the given index

        :param it: timepoint index

        :return: timepoint timepoint at index
        """
        return _amici.ExpData_getTimepoint(self, it)

    def setObservedData(self, *args):
        """
        *Overload 1:*

        Set all measurements.

        :type observedData: DoubleVector
        :param observedData: observed data (dimension: nt x nytrue, row-major)

        |

        *Overload 2:*

        Set measurements for a given observable index

        :type observedData: DoubleVector
        :param observedData: observed data (dimension: nt)
        :type iy: int
        :param iy: observed data index
        """
        return _amici.ExpData_setObservedData(self, *args)

    def isSetObservedData(self, it: int, iy: int) -> bool:
        """
        Whether there is a measurement for the given time- and observable-
        index.

        :param it: time index
        :param iy: observable index

        :return: boolean specifying if data was set
        """
        return _amici.ExpData_isSetObservedData(self, it, iy)

    def getObservedData(self) -> Sequence[float]:
        """
        Get all measurements.

        :return: observed data (dimension: nt x nytrue, row-major)
        """
        return _amici.ExpData_getObservedData(self)

    def getObservedDataPtr(self, it: int) -> 'float':
        """
        Get measurements for a given timepoint index.

        :param it: timepoint index

        :return: pointer to observed data at index (dimension: nytrue)
        """
        return _amici.ExpData_getObservedDataPtr(self, it)

    def setObservedDataStdDev(self, *args):
        """
        *Overload 1:*

        Set standard deviations for measurements.

        :type observedDataStdDev: DoubleVector
        :param observedDataStdDev: standard deviation of observed data (dimension:
            nt x nytrue, row-major)

        |

        *Overload 2:*

        Set identical standard deviation for all measurements.

        :type stdDev: float
        :param stdDev: standard deviation (dimension: scalar)

        |

        *Overload 3:*

        Set standard deviations of observed data for a
        specific observable index.

        :type observedDataStdDev: DoubleVector
        :param observedDataStdDev: standard deviation of observed data (dimension:
            nt)
        :type iy: int
        :param iy: observed data index

        |

        *Overload 4:*

        Set all standard deviation for a given observable index to the
        input value.

        :type stdDev: float
        :param stdDev: standard deviation (dimension: scalar)
        :type iy: int
        :param iy: observed data index
        """
        return _amici.ExpData_setObservedDataStdDev(self, *args)

    def isSetObservedDataStdDev(self, it: int, iy: int) -> bool:
        """
        Whether standard deviation for a measurement at
        specified timepoint- and observable index has been set.

        :param it: time index
        :param iy: observable index
        :return: boolean specifying if standard deviation of data was set
        """
        return _amici.ExpData_isSetObservedDataStdDev(self, it, iy)

    def getObservedDataStdDev(self) -> Sequence[float]:
        """
        Get measurement standard deviations.

        :return: standard deviation of observed data
        """
        return _amici.ExpData_getObservedDataStdDev(self)

    def getObservedDataStdDevPtr(self, it: int) -> 'float':
        """
        Get pointer to measurement standard deviations.

        :param it: timepoint index
        :return: pointer to standard deviation of observed data at index
        """
        return _amici.ExpData_getObservedDataStdDevPtr(self, it)

    def setObservedEvents(self, *args):
        """
        *Overload 1:*

        Set observed event data.

        :type observedEvents: DoubleVector
        :param observedEvents: observed data (dimension: nmaxevent x nztrue,
            row-major)

        |

        *Overload 2:*

        Set observed event data for specific event observable.

        :type observedEvents: DoubleVector
        :param observedEvents: observed data (dimension: nmaxevent)
        :type iz: int
        :param iz: observed event data index
        """
        return _amici.ExpData_setObservedEvents(self, *args)

    def isSetObservedEvents(self, ie: int, iz: int) -> bool:
        """
        Check whether event data at specified indices has been set.

        :param ie: event index
        :param iz: event observable index
        :return: boolean specifying if data was set
        """
        return _amici.ExpData_isSetObservedEvents(self, ie, iz)

    def getObservedEvents(self) -> Sequence[float]:
        """
        Get observed event data.

        :return: observed event data
        """
        return _amici.ExpData_getObservedEvents(self)

    def getObservedEventsPtr(self, ie: int) -> 'float':
        """
        Get pointer to observed data at ie-th occurrence.

        :param ie: event occurrence

        :return: pointer to observed event data at ie-th occurrence
        """
        return _amici.ExpData_getObservedEventsPtr(self, ie)

    def setObservedEventsStdDev(self, *args):
        """
        *Overload 1:*

        Set standard deviation of observed event data.

        :type observedEventsStdDev: DoubleVector
        :param observedEventsStdDev: standard deviation of observed event data

        |

        *Overload 2:*

        Set standard deviation of observed event data.

        :type stdDev: float
        :param stdDev: standard deviation (dimension: scalar)

        |

        *Overload 3:*

        Set standard deviation of observed data for a specific observable.

        :type observedEventsStdDev: DoubleVector
        :param observedEventsStdDev: standard deviation of observed data
            (dimension: nmaxevent)
        :type iz: int
        :param iz: observed data index

        |

        *Overload 4:*

        Set all standard deviations of a specific event-observable.

        :type stdDev: float
        :param stdDev: standard deviation (dimension: scalar)
        :type iz: int
        :param iz: observed data index
        """
        return _amici.ExpData_setObservedEventsStdDev(self, *args)

    def isSetObservedEventsStdDev(self, ie: int, iz: int) -> bool:
        """
        Check whether standard deviation of event data
        at specified indices has been set.

        :param ie: event index
        :param iz: event observable index
        :return: boolean specifying if standard deviation of event data was set
        """
        return _amici.ExpData_isSetObservedEventsStdDev(self, ie, iz)

    def getObservedEventsStdDev(self) -> Sequence[float]:
        """
        Get standard deviation of observed event data.

        :return: standard deviation of observed event data
        """
        return _amici.ExpData_getObservedEventsStdDev(self)

    def getObservedEventsStdDevPtr(self, ie: int) -> 'float':
        """
        Get pointer to standard deviation of
        observed event data at ie-th occurrence.

        :param ie: event occurrence

        :return: pointer to standard deviation of observed event data at ie-th
            occurrence
        """
        return _amici.ExpData_getObservedEventsStdDevPtr(self, ie)

    def clear_observations(self):
        """
        Set all observations and their standard deviations to NaN.

        Useful, e.g., after calling ExpData::setTimepoints.
        """
        return _amici.ExpData_clear_observations(self)
    id = property(_amici.ExpData_id_get, _amici.ExpData_id_set, doc='Arbitrary (not necessarily unique) identifier.')

    def __repr__(self):
        return _edata_repr(self)

    def __eq__(self, other):
        return other.__class__ == self.__class__ and __eq__(self, other)

    def __deepcopy__(self, memo):
        return type(self)(self)
_amici.ExpData_swigregister(ExpData)

def checkSigmaPositivity(*args):
    """
    *Overload 1:*

    checks input vector of sigmas for not strictly positive values

    :type sigmaVector: DoubleVector
    :param sigmaVector: vector input to be checked
    :type vectorName: string
    :param vectorName: name of the input

    |

    *Overload 2:*

    checks input scalar sigma for not strictly positive value

    :type sigma: float
    :param sigma: input to be checked
    :type sigmaName: string
    :param sigmaName: name of the input
    """
    return _amici.checkSigmaPositivity(*args)

def _solver_repr(self: 'Solver'):
    return '\n'.join([self.this.__repr__()[:-1], f'  reporting_mode: {RDataReporting(self.getReturnDataReportingMode())!r}', f'  sens_meth: {SensitivityMethod(self.getSensitivityMethod())!r}', f'  sens_order: {SensitivityOrder(self.getSensitivityOrder())!r}', f'  sens_meth_preeq: {SensitivityMethod(self.getSensitivityMethodPreequilibration())!r}', f'  maxsteps: {self.getMaxSteps()}', f'  maxtime: {self.getMaxTime()}s', f'  abs_tol: {self.getAbsoluteTolerance()}', f'  rel_tol: {self.getRelativeTolerance()}', f'  abs_tol_b: {self.getAbsoluteToleranceB()}', f'  rel_tol_b: {self.getRelativeToleranceB()}', f'  abs_tol_fsa: {self.getAbsoluteToleranceFSA()}', f'  rel_tol_fsa: {self.getRelativeToleranceFSA()}', f'  abs_tol_quad: {self.getAbsoluteToleranceQuadratures()}', f'  rel_tol_quad: {self.getRelativeToleranceQuadratures()}', f'  abs_tol_ss: {self.getAbsoluteToleranceSteadyState()}', f'  rel_tol_ss: {self.getRelativeToleranceSteadyState()}', f'  abs_tol_sss: {self.getAbsoluteToleranceSteadyStateSensi()}', f'  rel_tol_sss: {self.getRelativeToleranceSteadyStateSensi()}', f'  int_sens_meth: {InternalSensitivityMethod(self.getInternalSensitivityMethod())!r}', f'  int_type: {InterpolationType(self.getInterpolationType())!r}', f'  linsol: {LinearSolver(self.getLinearSolver())!r}', f'  lmm: {LinearMultistepMethod(self.getLinearMultistepMethod())!r}', f'  newton_damp_mode: {NewtonDampingFactorMode(self.getNewtonDampingFactorMode())!r}', f'  newton_damp_lb: {self.getNewtonDampingFactorLowerBound()}', f'  newton_maxsteps: {self.getNewtonMaxSteps()}', f'  newton_ss_check: {self.getNewtonStepSteadyStateCheck()}', f'  sens_ss_check: {self.getSensiSteadyStateCheck()}', f'  interpolation_type: {InterpolationType(self.getInterpolationType())!r}', f'  ism: {InternalSensitivityMethod(self.getInternalSensitivityMethod())!r}', f'  nlsol_iter: {NonlinearSolverIteration(self.getNonlinearSolverIteration())!r}', f'  stability_limit: {self.getStabilityLimitFlag()}', f'  state_ordering: {self.getStateOrdering()}', '>'])

class Solver(object):
    """
    The Solver class provides a generic interface to CVODES and IDAS solvers,
    individual realizations are realized in the CVodeSolver and the IDASolver
    class. All transient private/protected members (CVODES/IDAS memory, interface
    variables and status flags) are specified as mutable and not included in
    serialization or equality checks. No solver setting parameter should be
    marked mutable.

    NOTE: Any changes in data members here must be propagated to copy ctor,
    equality operator, serialization functions in serialization.h, and
    amici::hdf5::(read/write)SolverSettings(From/To)HDF5 in hdf5.cpp.
    """
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError('No constructor defined - class is abstract')
    __repr__ = _swig_repr
    __swig_destroy__ = _amici.delete_Solver

    def clone(self) -> 'Solver':
        """
        Clone this instance
        :return: The clone
        """
        return _amici.Solver_clone(self)

    def getSensitivityMethod(self) -> 'SensitivityMethod':
        """
        Return current sensitivity method
        :return: method enum
        """
        return _amici.Solver_getSensitivityMethod(self)

    def setSensitivityMethod(self, sensi_meth: 'SensitivityMethod'):
        """
        Set sensitivity method
        :param sensi_meth:
        """
        return _amici.Solver_setSensitivityMethod(self, sensi_meth)

    def getSensitivityMethodPreequilibration(self) -> 'SensitivityMethod':
        """
        Return current sensitivity method during preequilibration
        :return: method enum
        """
        return _amici.Solver_getSensitivityMethodPreequilibration(self)

    def setSensitivityMethodPreequilibration(self, sensi_meth_preeq: 'SensitivityMethod'):
        """
        Set sensitivity method for preequilibration
        :param sensi_meth_preeq:
        """
        return _amici.Solver_setSensitivityMethodPreequilibration(self, sensi_meth_preeq)

    def getNewtonMaxSteps(self) -> int:
        """
        Get maximum number of allowed Newton steps for steady state
        computation
        :return: 
        """
        return _amici.Solver_getNewtonMaxSteps(self)

    def setNewtonMaxSteps(self, newton_maxsteps: int):
        """
        Set maximum number of allowed Newton steps for steady state
        computation
        :param newton_maxsteps:
        """
        return _amici.Solver_setNewtonMaxSteps(self, newton_maxsteps)

    def getNewtonDampingFactorMode(self) -> 'NewtonDampingFactorMode':
        """
        Get a state of the damping factor used in the Newton solver
        :return: 
        """
        return _amici.Solver_getNewtonDampingFactorMode(self)

    def setNewtonDampingFactorMode(self, dampingFactorMode: 'NewtonDampingFactorMode'):
        """
        Turn on/off a damping factor in the Newton method
        :param dampingFactorMode:
        """
        return _amici.Solver_setNewtonDampingFactorMode(self, dampingFactorMode)

    def getNewtonDampingFactorLowerBound(self) -> 'float':
        """
        Get a lower bound of the damping factor used in the Newton solver
        :return: 
        """
        return _amici.Solver_getNewtonDampingFactorLowerBound(self)

    def setNewtonDampingFactorLowerBound(self, dampingFactorLowerBound: 'float'):
        """
        Set a lower bound of the damping factor in the Newton solver
        :param dampingFactorLowerBound:
        """
        return _amici.Solver_setNewtonDampingFactorLowerBound(self, dampingFactorLowerBound)

    def getSensitivityOrder(self) -> 'SensitivityOrder':
        """
        Get sensitivity order
        :return: sensitivity order
        """
        return _amici.Solver_getSensitivityOrder(self)

    def setSensitivityOrder(self, sensi: 'SensitivityOrder'):
        """
        Set the sensitivity order
        :param sensi: sensitivity order
        """
        return _amici.Solver_setSensitivityOrder(self, sensi)

    def getRelativeTolerance(self) -> 'float':
        """
        Get the relative tolerances for the forward problem

        Same tolerance is used for the backward problem if not specified
        differently via setRelativeToleranceASA.

        :return: relative tolerances
        """
        return _amici.Solver_getRelativeTolerance(self)

    def setRelativeTolerance(self, rtol: 'float'):
        """
        Sets the relative tolerances for the forward problem

        Same tolerance is used for the backward problem if not specified
        differently via setRelativeToleranceASA.

        :param rtol: relative tolerance (non-negative number)
        """
        return _amici.Solver_setRelativeTolerance(self, rtol)

    def getAbsoluteTolerance(self) -> 'float':
        """
        Get the absolute tolerances for the forward problem

        Same tolerance is used for the backward problem if not specified
        differently via setAbsoluteToleranceASA.

        :return: absolute tolerances
        """
        return _amici.Solver_getAbsoluteTolerance(self)

    def setAbsoluteTolerance(self, atol: 'float'):
        """
        Sets the absolute tolerances for the forward problem

        Same tolerance is used for the backward problem if not specified
        differently via setAbsoluteToleranceASA.

        :param atol: absolute tolerance (non-negative number)
        """
        return _amici.Solver_setAbsoluteTolerance(self, atol)

    def getRelativeToleranceFSA(self) -> 'float':
        """
        Returns the relative tolerances for the forward sensitivity
        problem
        :return: relative tolerances
        """
        return _amici.Solver_getRelativeToleranceFSA(self)

    def setRelativeToleranceFSA(self, rtol: 'float'):
        """
        Sets the relative tolerances for the forward sensitivity problem
        :param rtol: relative tolerance (non-negative number)
        """
        return _amici.Solver_setRelativeToleranceFSA(self, rtol)

    def getAbsoluteToleranceFSA(self) -> 'float':
        """
        Returns the absolute tolerances for the forward sensitivity
        problem
        :return: absolute tolerances
        """
        return _amici.Solver_getAbsoluteToleranceFSA(self)

    def setAbsoluteToleranceFSA(self, atol: 'float'):
        """
        Sets the absolute tolerances for the forward sensitivity problem
        :param atol: absolute tolerance (non-negative number)
        """
        return _amici.Solver_setAbsoluteToleranceFSA(self, atol)

    def getRelativeToleranceB(self) -> 'float':
        """
        Returns the relative tolerances for the adjoint sensitivity
        problem
        :return: relative tolerances
        """
        return _amici.Solver_getRelativeToleranceB(self)

    def setRelativeToleranceB(self, rtol: 'float'):
        """
        Sets the relative tolerances for the adjoint sensitivity problem
        :param rtol: relative tolerance (non-negative number)
        """
        return _amici.Solver_setRelativeToleranceB(self, rtol)

    def getAbsoluteToleranceB(self) -> 'float':
        """
        Returns the absolute tolerances for the backward problem for
        adjoint sensitivity analysis
        :return: absolute tolerances
        """
        return _amici.Solver_getAbsoluteToleranceB(self)

    def setAbsoluteToleranceB(self, atol: 'float'):
        """
        Sets the absolute tolerances for the backward problem for
        adjoint sensitivity analysis
        :param atol: absolute tolerance (non-negative number)
        """
        return _amici.Solver_setAbsoluteToleranceB(self, atol)

    def getRelativeToleranceQuadratures(self) -> 'float':
        """
        Returns the relative tolerance for the quadrature problem
        :return: relative tolerance
        """
        return _amici.Solver_getRelativeToleranceQuadratures(self)

    def setRelativeToleranceQuadratures(self, rtol: 'float'):
        """
        sets the relative tolerance for the quadrature problem
        :param rtol: relative tolerance (non-negative number)
        """
        return _amici.Solver_setRelativeToleranceQuadratures(self, rtol)

    def getAbsoluteToleranceQuadratures(self) -> 'float':
        """
        returns the absolute tolerance for the quadrature problem
        :return: absolute tolerance
        """
        return _amici.Solver_getAbsoluteToleranceQuadratures(self)

    def setAbsoluteToleranceQuadratures(self, atol: 'float'):
        """
        sets the absolute tolerance for the quadrature problem
        :param atol: absolute tolerance (non-negative number)
        """
        return _amici.Solver_setAbsoluteToleranceQuadratures(self, atol)

    def getSteadyStateToleranceFactor(self) -> 'float':
        """
        returns the steady state simulation tolerance factor.

        Steady state simulation tolerances are the product of the simulation
        tolerances and this factor, unless manually set with
        `set(Absolute/Relative)ToleranceSteadyState()`.
        :return: steady state simulation tolerance factor
        """
        return _amici.Solver_getSteadyStateToleranceFactor(self)

    def setSteadyStateToleranceFactor(self, factor: 'float'):
        """
        set the steady state simulation tolerance factor.

        Steady state simulation tolerances are the product of the simulation
        tolerances and this factor, unless manually set with
        `set(Absolute/Relative)ToleranceSteadyState()`.
        :param factor: tolerance factor (non-negative number)
        """
        return _amici.Solver_setSteadyStateToleranceFactor(self, factor)

    def getRelativeToleranceSteadyState(self) -> 'float':
        """
        returns the relative tolerance for the steady state problem
        :return: relative tolerance
        """
        return _amici.Solver_getRelativeToleranceSteadyState(self)

    def setRelativeToleranceSteadyState(self, rtol: 'float'):
        """
        sets the relative tolerance for the steady state problem
        :param rtol: relative tolerance (non-negative number)
        """
        return _amici.Solver_setRelativeToleranceSteadyState(self, rtol)

    def getAbsoluteToleranceSteadyState(self) -> 'float':
        """
        returns the absolute tolerance for the steady state problem
        :return: absolute tolerance
        """
        return _amici.Solver_getAbsoluteToleranceSteadyState(self)

    def setAbsoluteToleranceSteadyState(self, atol: 'float'):
        """
        sets the absolute tolerance for the steady state problem
        :param atol: absolute tolerance (non-negative number)
        """
        return _amici.Solver_setAbsoluteToleranceSteadyState(self, atol)

    def getSteadyStateSensiToleranceFactor(self) -> 'float':
        """
        returns the steady state sensitivity simulation tolerance factor.

        Steady state sensitivity simulation tolerances are the product of the
        sensitivity simulation tolerances and this factor, unless manually set
        with `set(Absolute/Relative)ToleranceSteadyStateSensi()`.
        :return: steady state simulation tolerance factor
        """
        return _amici.Solver_getSteadyStateSensiToleranceFactor(self)

    def setSteadyStateSensiToleranceFactor(self, factor: 'float'):
        """
        set the steady state sensitivity simulation tolerance factor.

        Steady state sensitivity simulation tolerances are the product of the
        sensitivity simulation tolerances and this factor, unless manually set
        with `set(Absolute/Relative)ToleranceSteadyStateSensi()`.
        :param factor: tolerance factor (non-negative number)
        """
        return _amici.Solver_setSteadyStateSensiToleranceFactor(self, factor)

    def getRelativeToleranceSteadyStateSensi(self) -> 'float':
        """
        returns the relative tolerance for the sensitivities of the
        steady state problem
        :return: relative tolerance
        """
        return _amici.Solver_getRelativeToleranceSteadyStateSensi(self)

    def setRelativeToleranceSteadyStateSensi(self, rtol: 'float'):
        """
        sets the relative tolerance for the sensitivities of the
        steady state problem
        :param rtol: relative tolerance (non-negative number)
        """
        return _amici.Solver_setRelativeToleranceSteadyStateSensi(self, rtol)

    def getAbsoluteToleranceSteadyStateSensi(self) -> 'float':
        """
        returns the absolute tolerance for the sensitivities of the
        steady state problem
        :return: absolute tolerance
        """
        return _amici.Solver_getAbsoluteToleranceSteadyStateSensi(self)

    def setAbsoluteToleranceSteadyStateSensi(self, atol: 'float'):
        """
        sets the absolute tolerance for the sensitivities of the
        steady state problem
        :param atol: absolute tolerance (non-negative number)
        """
        return _amici.Solver_setAbsoluteToleranceSteadyStateSensi(self, atol)

    def getMaxSteps(self) -> int:
        """
        returns the maximum number of solver steps for the forward
        problem
        :return: maximum number of solver steps
        """
        return _amici.Solver_getMaxSteps(self)

    def setMaxSteps(self, maxsteps: int):
        """
        sets the maximum number of solver steps for the forward problem
        :param maxsteps: maximum number of solver steps (positive number)
        """
        return _amici.Solver_setMaxSteps(self, maxsteps)

    def getMaxTime(self) -> 'float':
        """
        Returns the maximum time allowed for integration
        :return: Time in seconds
        """
        return _amici.Solver_getMaxTime(self)

    def setMaxTime(self, maxtime: 'float'):
        """
        Set the maximum CPU time allowed for integration
        :param maxtime: Time in seconds. Zero means infinite time.
        """
        return _amici.Solver_setMaxTime(self, maxtime)

    def getMaxStepsBackwardProblem(self) -> int:
        """
        returns the maximum number of solver steps for the backward
        problem
        :return: maximum number of solver steps
        """
        return _amici.Solver_getMaxStepsBackwardProblem(self)

    def setMaxStepsBackwardProblem(self, maxsteps: int):
        """
        sets the maximum number of solver steps for the backward problem

        :param maxsteps: maximum number of solver steps (non-negative number)

        Notes: default behaviour (100 times the value for the forward problem) can
        be restored by passing maxsteps=0
        """
        return _amici.Solver_setMaxStepsBackwardProblem(self, maxsteps)

    def getLinearMultistepMethod(self) -> 'LinearMultistepMethod':
        """
        returns the linear system multistep method
        :return: linear system multistep method
        """
        return _amici.Solver_getLinearMultistepMethod(self)

    def setLinearMultistepMethod(self, lmm: 'LinearMultistepMethod'):
        """
        sets the linear system multistep method
        :param lmm: linear system multistep method
        """
        return _amici.Solver_setLinearMultistepMethod(self, lmm)

    def getNonlinearSolverIteration(self) -> 'NonlinearSolverIteration':
        """
        returns the nonlinear system solution method
        :return: 
        """
        return _amici.Solver_getNonlinearSolverIteration(self)

    def setNonlinearSolverIteration(self, iter: 'NonlinearSolverIteration'):
        """
        sets the nonlinear system solution method
        :param iter: nonlinear system solution method
        """
        return _amici.Solver_setNonlinearSolverIteration(self, iter)

    def getInterpolationType(self) -> 'InterpolationType':
        """
        getInterpolationType
        :return: 
        """
        return _amici.Solver_getInterpolationType(self)

    def setInterpolationType(self, interpType: 'InterpolationType'):
        """
        sets the interpolation of the forward solution that is used for
        the backwards problem
        :param interpType: interpolation type
        """
        return _amici.Solver_setInterpolationType(self, interpType)

    def getStateOrdering(self) -> int:
        """
        Gets KLU / SuperLUMT state ordering mode

        :return: State-ordering as integer according to
            SUNLinSolKLU::StateOrdering or SUNLinSolSuperLUMT::StateOrdering (which
            differ).
        """
        return _amici.Solver_getStateOrdering(self)

    def setStateOrdering(self, ordering: int):
        """
        Sets KLU / SuperLUMT state ordering mode

        This only applies when linsol is set to LinearSolver::KLU or
        LinearSolver::SuperLUMT. Mind the difference between
        SUNLinSolKLU::StateOrdering and SUNLinSolSuperLUMT::StateOrdering.
        :param ordering: state ordering
        """
        return _amici.Solver_setStateOrdering(self, ordering)

    def getStabilityLimitFlag(self) -> bool:
        """
        returns stability limit detection mode
        :return: stldet can be false (deactivated) or true (activated)
        """
        return _amici.Solver_getStabilityLimitFlag(self)

    def setStabilityLimitFlag(self, stldet: bool):
        """
        set stability limit detection mode
        :param stldet: can be false (deactivated) or true (activated)
        """
        return _amici.Solver_setStabilityLimitFlag(self, stldet)

    def getLinearSolver(self) -> 'LinearSolver':
        """
        getLinearSolver
        :return: 
        """
        return _amici.Solver_getLinearSolver(self)

    def setLinearSolver(self, linsol: 'LinearSolver'):
        """
        setLinearSolver
        :param linsol:
        """
        return _amici.Solver_setLinearSolver(self, linsol)

    def getInternalSensitivityMethod(self) -> 'InternalSensitivityMethod':
        """
        returns the internal sensitivity method
        :return: internal sensitivity method
        """
        return _amici.Solver_getInternalSensitivityMethod(self)

    def setInternalSensitivityMethod(self, ism: 'InternalSensitivityMethod'):
        """
        sets the internal sensitivity method
        :param ism: internal sensitivity method
        """
        return _amici.Solver_setInternalSensitivityMethod(self, ism)

    def getReturnDataReportingMode(self) -> 'RDataReporting':
        """
        returns the ReturnData reporting mode
        :return: ReturnData reporting mode
        """
        return _amici.Solver_getReturnDataReportingMode(self)

    def setReturnDataReportingMode(self, rdrm: 'RDataReporting'):
        """
        sets the ReturnData reporting mode
        :param rdrm: ReturnData reporting mode
        """
        return _amici.Solver_setReturnDataReportingMode(self, rdrm)

    def nx(self) -> int:
        """
        number of states with which the solver was initialized
        :return: x.getLength()
        """
        return _amici.Solver_nx(self)

    def nplist(self) -> int:
        """
        number of parameters with which the solver was initialized
        :return: sx.getLength()
        """
        return _amici.Solver_nplist(self)

    def nquad(self) -> int:
        """
        number of quadratures with which the solver was initialized
        :return: xQB.getLength()
        """
        return _amici.Solver_nquad(self)

    def computingFSA(self) -> bool:
        """
        check if FSA is being computed
        :return: flag
        """
        return _amici.Solver_computingFSA(self)

    def computingASA(self) -> bool:
        """
        check if ASA is being computed
        :return: flag
        """
        return _amici.Solver_computingASA(self)

    def getNewtonStepSteadyStateCheck(self) -> bool:
        """
        Returns how convergence checks for steadystate computation are
        performed. If activated, convergence checks are limited to every 25 steps
        in the simulation solver to limit performance impact.
        :return: boolean flag indicating newton step (true) or the right hand side
            (false)
        """
        return _amici.Solver_getNewtonStepSteadyStateCheck(self)

    def getSensiSteadyStateCheck(self) -> bool:
        """
        Returns how convergence checks for steadystate computation are
        performed.
        :return: boolean flag indicating state and sensitivity equations (true) or
            only state variables (false).
        """
        return _amici.Solver_getSensiSteadyStateCheck(self)

    def setNewtonStepSteadyStateCheck(self, flag: bool):
        """
        Sets how convergence checks for steadystate computation are
        performed.
        :param flag: boolean flag to pick newton step (true) or the right hand
            side (false, default)
        """
        return _amici.Solver_setNewtonStepSteadyStateCheck(self, flag)

    def setSensiSteadyStateCheck(self, flag: bool):
        """
        Sets for which variables convergence checks for steadystate
        computation are performed.
        :param flag: boolean flag to pick state and sensitivity equations (true,
            default) or only state variables (false).
        """
        return _amici.Solver_setSensiSteadyStateCheck(self, flag)

    def setMaxNonlinIters(self, max_nonlin_iters: int):
        """
        Set the maximum number of nonlinear solver iterations permitted
        per step.
        :param max_nonlin_iters: maximum number of nonlinear solver iterations
        """
        return _amici.Solver_setMaxNonlinIters(self, max_nonlin_iters)

    def getMaxNonlinIters(self) -> int:
        """
        Get the maximum number of nonlinear solver iterations permitted
        per step.
        :return: maximum number of nonlinear solver iterations
        """
        return _amici.Solver_getMaxNonlinIters(self)

    def setMaxConvFails(self, max_conv_fails: int):
        """
        Set the maximum number of nonlinear solver convergence failures
        permitted per step.
        :param max_conv_fails: maximum number of nonlinear solver convergence
        """
        return _amici.Solver_setMaxConvFails(self, max_conv_fails)

    def getMaxConvFails(self) -> int:
        """
        Get the maximum number of nonlinear solver convergence failures
        permitted per step.
        :return: maximum number of nonlinear solver convergence
        """
        return _amici.Solver_getMaxConvFails(self)

    def setConstraints(self, constraints: Sequence[float]):
        """
        Set constraints on the model state.

        See
        https://sundials.readthedocs.io/en/latest/cvode/Usage/index.html#c.CVodeSetConstraints.

        :param constraints:
        """
        return _amici.Solver_setConstraints(self, constraints)

    def getConstraints(self) -> Sequence[float]:
        """
        Get constraints on the model state.
        :return: constraints
        """
        return _amici.Solver_getConstraints(self)

    def setMaxStepSize(self, max_step_size: 'float'):
        """
        Set the maximum step size
        :param max_step_size: maximum step size. `0.0` means no limit.
        """
        return _amici.Solver_setMaxStepSize(self, max_step_size)

    def getMaxStepSize(self) -> 'float':
        """
        Get the maximum step size
        :return: maximum step size
        """
        return _amici.Solver_getMaxStepSize(self)
    logger = property(_amici.Solver_logger_get, _amici.Solver_logger_set, doc=' logger')

    def __deepcopy__(self, memo):
        return self.clone()
_amici.Solver_swigregister(Solver)

def wrapErrHandlerFn(error_code: int, module: 'string', function: 'string', msg: 'string', eh_data: 'None'):
    """
    Extracts diagnosis information from solver memory block and
    passes them to the specified output function

    :param error_code: error identifier
    :param module: name of the module in which the error occurred
    :param function: name of the function in which the error occurred
    :param msg: error message
    :param eh_data: amici::Solver as void*
    """
    return _amici.wrapErrHandlerFn(error_code, module, function, msg, eh_data)

class IDASolver(Solver):
    """The IDASolver class is a wrapper around the SUNDIALS IDAS solver."""
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    __swig_destroy__ = _amici.delete_IDASolver

    def clone(self) -> 'Solver':
        """
        Clone this instance
        :return: The clone
        """
        return _amici.IDASolver_clone(self)

    def reInitPostProcessF(self, tnext):
        return _amici.IDASolver_reInitPostProcessF(self, tnext)

    def reInitPostProcessB(self, tnext):
        return _amici.IDASolver_reInitPostProcessB(self, tnext)

    def quadSStolerancesB(self, which, reltolQB, abstolQB):
        return _amici.IDASolver_quadSStolerancesB(self, which, reltolQB, abstolQB)

    def quadSStolerances(self, reltolQ, abstolQ):
        return _amici.IDASolver_quadSStolerances(self, reltolQ, abstolQ)

    def solve(self, tout, itask):
        return _amici.IDASolver_solve(self, tout, itask)

    def solveF(self, tout, itask, ncheckPtr):
        return _amici.IDASolver_solveF(self, tout, itask, ncheckPtr)

    def getDky(self, t, k):
        return _amici.IDASolver_getDky(self, t, k)

    def getSens(self):
        return _amici.IDASolver_getSens(self)

    def getSensDky(self, t, k):
        return _amici.IDASolver_getSensDky(self, t, k)

    def getB(self, which):
        return _amici.IDASolver_getB(self, which)

    def getDkyB(self, t, k, which):
        return _amici.IDASolver_getDkyB(self, t, k, which)

    def getQuadB(self, which):
        return _amici.IDASolver_getQuadB(self, which)

    def getQuadDkyB(self, t, k, which):
        return _amici.IDASolver_getQuadDkyB(self, t, k, which)

    def getQuad(self, t):
        return _amici.IDASolver_getQuad(self, t)

    def getQuadDky(self, t, k):
        return _amici.IDASolver_getQuadDky(self, t, k)

    def setStopTime(self, tstop):
        return _amici.IDASolver_setStopTime(self, tstop)

    def getModel(self):
        return _amici.IDASolver_getModel(self)

    def setLinearSolver(self):
        return _amici.IDASolver_setLinearSolver(self)

    def setLinearSolverB(self, which):
        return _amici.IDASolver_setLinearSolverB(self, which)

    def setNonLinearSolver(self):
        return _amici.IDASolver_setNonLinearSolver(self)

    def setNonLinearSolverSens(self):
        return _amici.IDASolver_setNonLinearSolverSens(self)

    def setNonLinearSolverB(self, which):
        return _amici.IDASolver_setNonLinearSolverB(self, which)

    def __repr__(self):
        return _solver_repr(self)

    def __init__(self, *args):
        _amici.IDASolver_swiginit(self, _amici.new_IDASolver(*args))
_amici.IDASolver_swigregister(IDASolver)

class CVodeSolver(Solver):
    """The CVodeSolver class is a wrapper around the SUNDIALS CVODES solver."""
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    __swig_destroy__ = _amici.delete_CVodeSolver

    def clone(self) -> 'Solver':
        """
        Clone this instance
        :return: The clone
        """
        return _amici.CVodeSolver_clone(self)

    def solve(self, tout, itask):
        return _amici.CVodeSolver_solve(self, tout, itask)

    def solveF(self, tout, itask, ncheckPtr):
        return _amici.CVodeSolver_solveF(self, tout, itask, ncheckPtr)

    def getDky(self, t, k):
        return _amici.CVodeSolver_getDky(self, t, k)

    def getSensDky(self, t, k):
        return _amici.CVodeSolver_getSensDky(self, t, k)

    def getQuadDkyB(self, t, k, which):
        return _amici.CVodeSolver_getQuadDkyB(self, t, k, which)

    def getDkyB(self, t, k, which):
        return _amici.CVodeSolver_getDkyB(self, t, k, which)

    def setStopTime(self, tstop):
        return _amici.CVodeSolver_setStopTime(self, tstop)

    def getModel(self):
        return _amici.CVodeSolver_getModel(self)

    def setLinearSolver(self, *args):
        return _amici.CVodeSolver_setLinearSolver(self, *args)

    def setLinearSolverB(self, which):
        return _amici.CVodeSolver_setLinearSolverB(self, which)

    def setNonLinearSolver(self):
        return _amici.CVodeSolver_setNonLinearSolver(self)

    def setNonLinearSolverSens(self):
        return _amici.CVodeSolver_setNonLinearSolverSens(self)

    def setNonLinearSolverB(self, which):
        return _amici.CVodeSolver_setNonLinearSolverB(self, which)

    def __repr__(self):
        return _solver_repr(self)

    def __init__(self, *args):
        _amici.CVodeSolver_swiginit(self, _amici.new_CVodeSolver(*args))
_amici.CVodeSolver_swigregister(CVodeSolver)
ModelQuantity_J = _amici.ModelQuantity_J
ModelQuantity_JB = _amici.ModelQuantity_JB
ModelQuantity_Jv = _amici.ModelQuantity_Jv
ModelQuantity_JvB = _amici.ModelQuantity_JvB
ModelQuantity_JDiag = _amici.ModelQuantity_JDiag
ModelQuantity_sx = _amici.ModelQuantity_sx
ModelQuantity_sy = _amici.ModelQuantity_sy
ModelQuantity_sz = _amici.ModelQuantity_sz
ModelQuantity_srz = _amici.ModelQuantity_srz
ModelQuantity_ssigmay = _amici.ModelQuantity_ssigmay
ModelQuantity_ssigmaz = _amici.ModelQuantity_ssigmaz
ModelQuantity_xdot = _amici.ModelQuantity_xdot
ModelQuantity_sxdot = _amici.ModelQuantity_sxdot
ModelQuantity_xBdot = _amici.ModelQuantity_xBdot
ModelQuantity_x0_rdata = _amici.ModelQuantity_x0_rdata
ModelQuantity_x0 = _amici.ModelQuantity_x0
ModelQuantity_x_rdata = _amici.ModelQuantity_x_rdata
ModelQuantity_x = _amici.ModelQuantity_x
ModelQuantity_dwdw = _amici.ModelQuantity_dwdw
ModelQuantity_dwdx = _amici.ModelQuantity_dwdx
ModelQuantity_dwdp = _amici.ModelQuantity_dwdp
ModelQuantity_y = _amici.ModelQuantity_y
ModelQuantity_dydp = _amici.ModelQuantity_dydp
ModelQuantity_dydx = _amici.ModelQuantity_dydx
ModelQuantity_w = _amici.ModelQuantity_w
ModelQuantity_root = _amici.ModelQuantity_root
ModelQuantity_qBdot = _amici.ModelQuantity_qBdot
ModelQuantity_qBdot_ss = _amici.ModelQuantity_qBdot_ss
ModelQuantity_xBdot_ss = _amici.ModelQuantity_xBdot_ss
ModelQuantity_JSparseB_ss = _amici.ModelQuantity_JSparseB_ss
ModelQuantity_deltax = _amici.ModelQuantity_deltax
ModelQuantity_deltasx = _amici.ModelQuantity_deltasx
ModelQuantity_deltaxB = _amici.ModelQuantity_deltaxB
ModelQuantity_k = _amici.ModelQuantity_k
ModelQuantity_p = _amici.ModelQuantity_p
ModelQuantity_ts = _amici.ModelQuantity_ts
ModelQuantity_dJydy = _amici.ModelQuantity_dJydy
ModelQuantity_dJydy_matlab = _amici.ModelQuantity_dJydy_matlab
ModelQuantity_deltaqB = _amici.ModelQuantity_deltaqB
ModelQuantity_dsigmaydp = _amici.ModelQuantity_dsigmaydp
ModelQuantity_dsigmaydy = _amici.ModelQuantity_dsigmaydy
ModelQuantity_dsigmazdp = _amici.ModelQuantity_dsigmazdp
ModelQuantity_dJydsigma = _amici.ModelQuantity_dJydsigma
ModelQuantity_dJydx = _amici.ModelQuantity_dJydx
ModelQuantity_dzdx = _amici.ModelQuantity_dzdx
ModelQuantity_dzdp = _amici.ModelQuantity_dzdp
ModelQuantity_dJrzdsigma = _amici.ModelQuantity_dJrzdsigma
ModelQuantity_dJrzdz = _amici.ModelQuantity_dJrzdz
ModelQuantity_dJrzdx = _amici.ModelQuantity_dJrzdx
ModelQuantity_dJzdsigma = _amici.ModelQuantity_dJzdsigma
ModelQuantity_dJzdz = _amici.ModelQuantity_dJzdz
ModelQuantity_dJzdx = _amici.ModelQuantity_dJzdx
ModelQuantity_drzdp = _amici.ModelQuantity_drzdp
ModelQuantity_drzdx = _amici.ModelQuantity_drzdx

class Model(AbstractModel, ModelDimensions):
    """
    The Model class represents an AMICI ODE/DAE model.

    The model can compute various model related quantities based on symbolically
    generated code.
    """
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError('No constructor defined - class is abstract')
    __repr__ = _swig_repr
    __swig_destroy__ = _amici.delete_Model

    def clone(self) -> 'Model':
        """
        Clone this instance.
        :return: The clone
        """
        return _amici.Model_clone(self)

    def initializeSplines(self):
        """Initialization of spline functions"""
        return _amici.Model_initializeSplines(self)

    def initializeSplineSensitivities(self):
        """Initialization of spline sensitivity functions"""
        return _amici.Model_initializeSplineSensitivities(self)

    def nplist(self) -> int:
        """
        Get number of parameters wrt to which sensitivities are computed.
        :return: Length of sensitivity index vector
        """
        return _amici.Model_nplist(self)

    def np(self) -> int:
        """
        Get total number of model parameters.
        :return: Length of parameter vector
        """
        return _amici.Model_np(self)

    def nk(self) -> int:
        """
        Get number of constants
        :return: Length of constant vector
        """
        return _amici.Model_nk(self)

    def ncl(self) -> int:
        """
        Get number of conservation laws.
        :return: Number of conservation laws (i.e., difference between `nx_rdata`
            and `nx_solver`).
        """
        return _amici.Model_ncl(self)

    def nx_reinit(self) -> int:
        """
        Get number of solver states subject to reinitialization.
        :return: Model member `nx_solver_reinit`
        """
        return _amici.Model_nx_reinit(self)

    def k(self) -> 'float':
        """
        Get fixed parameters.
        :return: Pointer to constants array
        """
        return _amici.Model_k(self)

    def nMaxEvent(self) -> int:
        """
        Get maximum number of events that may occur for each type.
        :return: Maximum number of events that may occur for each type
        """
        return _amici.Model_nMaxEvent(self)

    def setNMaxEvent(self, nmaxevent: int):
        """
        Set maximum number of events that may occur for each type.
        :param nmaxevent: Maximum number of events that may occur for each type
        """
        return _amici.Model_setNMaxEvent(self, nmaxevent)

    def nt(self) -> int:
        """
        Get number of timepoints.
        :return: Number of timepoints
        """
        return _amici.Model_nt(self)

    def getParameterScale(self) -> 'ParameterScalingVector':
        """
        Get parameter scale for each parameter.
        :return: Vector of parameter scales
        """
        return _amici.Model_getParameterScale(self)

    def getUnscaledParameters(self) -> Sequence[float]:
        """
        Get parameters with transformation according to parameter scale
        applied.
        :return: Unscaled parameters
        """
        return _amici.Model_getUnscaledParameters(self)

    def getParameters(self) -> Sequence[float]:
        """
        Get parameter vector.
        :return: The user-set parameters (see also `Model::getUnscaledParameters`)
        """
        return _amici.Model_getParameters(self)

    def getParameterById(self, par_id: 'str') -> 'float':
        """
        Get value of first model parameter with the specified ID.
        :param par_id: Parameter ID
        :return: Parameter value
        """
        return _amici.Model_getParameterById(self, par_id)

    def getParameterByName(self, par_name: 'str') -> 'float':
        """
        Get value of first model parameter with the specified name.
        :param par_name: Parameter name
        :return: Parameter value
        """
        return _amici.Model_getParameterByName(self, par_name)

    def setParameters(self, p: Sequence[float]):
        """
        Set the parameter vector.
        :param p: Vector of parameters
        """
        return _amici.Model_setParameters(self, p)

    def setParameterById(self, *args):
        """
        *Overload 1:*

        Set model parameters according to the parameter IDs and mapped
        values.
        :type p: StringDoubleMap
        :param p: Map of parameters IDs and values
        :type ignoreErrors: boolean, optional
        :param ignoreErrors: Ignore errors such as parameter IDs in p which are
            not model parameters

        |

        *Overload 2:*

        Set value of first model parameter with the specified ID.
        :type par_id: str
        :param par_id: Parameter ID
        :type value: float
        :param value: Parameter value
        """
        return _amici.Model_setParameterById(self, *args)

    def setParametersByIdRegex(self, par_id_regex: 'str', value: 'float') -> int:
        """
        Set all values of model parameters with IDs matching the specified
        regular expression.
        :param par_id_regex: Parameter ID regex
        :param value: Parameter value
        :return: Number of parameter IDs that matched the regex
        """
        return _amici.Model_setParametersByIdRegex(self, par_id_regex, value)

    def setParameterByName(self, *args):
        """
        *Overload 1:*

        Set value of first model parameter with the specified name.
        :type par_name: str
        :param par_name: Parameter name
        :type value: float
        :param value: Parameter value

        |

        *Overload 2:*

        Set model parameters according to the parameter name and mapped
        values.
        :type p: StringDoubleMap
        :param p: Map of parameters names and values
        :type ignoreErrors: boolean, optional
        :param ignoreErrors: Ignore errors such as parameter names in p which are
            not model parameters

        |

        *Overload 3:*

        Set model parameters according to the parameter name and mapped
        values.
        :type p: StringDoubleMap
        :param p: Map of parameters names and values
        :param ignoreErrors: Ignore errors such as parameter names in p which are
            not model parameters
        """
        return _amici.Model_setParameterByName(self, *args)

    def setParametersByNameRegex(self, par_name_regex: 'str', value: 'float') -> int:
        """
        Set all values of all model parameters with names matching the
        specified regex.
        :param par_name_regex: Parameter name regex
        :param value: Parameter value
        :return: Number of fixed parameter names that matched the regex
        """
        return _amici.Model_setParametersByNameRegex(self, par_name_regex, value)

    def getFixedParameters(self) -> Sequence[float]:
        """
        Get values of fixed parameters.
        :return: Vector of fixed parameters with same ordering as in
            Model::getFixedParameterIds
        """
        return _amici.Model_getFixedParameters(self)

    def getFixedParameterById(self, par_id: 'str') -> 'float':
        """
        Get value of fixed parameter with the specified ID.
        :param par_id: Parameter ID
        :return: Parameter value
        """
        return _amici.Model_getFixedParameterById(self, par_id)

    def getFixedParameterByName(self, par_name: 'str') -> 'float':
        """
        Get value of fixed parameter with the specified name.

        If multiple parameters have the same name, the first parameter with
        matching name is returned.

        :param par_name: Parameter name
        :return: Parameter value
        """
        return _amici.Model_getFixedParameterByName(self, par_name)

    def setFixedParameters(self, k: Sequence[float]):
        """
        Set values for constants.
        :param k: Vector of fixed parameters
        """
        return _amici.Model_setFixedParameters(self, k)

    def setFixedParameterById(self, par_id: 'str', value: 'float'):
        """
        Set value of first fixed parameter with the specified ID.
        :param par_id: Fixed parameter id
        :param value: Fixed parameter value
        """
        return _amici.Model_setFixedParameterById(self, par_id, value)

    def setFixedParametersByIdRegex(self, par_id_regex: 'str', value: 'float') -> int:
        """
        Set values of all fixed parameters with the ID matching the
        specified regex.
        :param par_id_regex: Fixed parameter name regex
        :param value: Fixed parameter value
        :return: Number of fixed parameter IDs that matched the regex
        """
        return _amici.Model_setFixedParametersByIdRegex(self, par_id_regex, value)

    def setFixedParameterByName(self, par_name: 'str', value: 'float'):
        """
        Set value of first fixed parameter with the specified name.
        :param par_name: Fixed parameter ID
        :param value: Fixed parameter value
        """
        return _amici.Model_setFixedParameterByName(self, par_name, value)

    def setFixedParametersByNameRegex(self, par_name_regex: 'str', value: 'float') -> int:
        """
        Set value of all fixed parameters with name matching the specified
        regex.
        :param par_name_regex: Fixed parameter name regex
        :param value: Fixed parameter value
        :return: Number of fixed parameter names that matched the regex
        """
        return _amici.Model_setFixedParametersByNameRegex(self, par_name_regex, value)

    def getName(self) -> 'str':
        """
        Get the model name.
        :return: Model name
        """
        return _amici.Model_getName(self)

    def hasParameterNames(self) -> bool:
        """
        Report whether the model has parameter names set.

        :return: Boolean indicating whether parameter names were set. Also returns
            `true` if the number of corresponding variables is just zero.
        """
        return _amici.Model_hasParameterNames(self)

    def getParameterNames(self) -> Sequence[str]:
        """
        Get names of the model parameters.
        :return: The parameter names
        """
        return _amici.Model_getParameterNames(self)

    def hasStateNames(self) -> bool:
        """
        Report whether the model has state names set.

        :return: Boolean indicating whether state names were set. Also returns
            `true` if the number of corresponding variables is just zero.
        """
        return _amici.Model_hasStateNames(self)

    def getStateNames(self) -> Sequence[str]:
        """
        Get names of the model states.
        :return: State names
        """
        return _amici.Model_getStateNames(self)

    def getStateNamesSolver(self) -> Sequence[str]:
        """
        Get names of the solver states.
        :return: State names
        """
        return _amici.Model_getStateNamesSolver(self)

    def hasFixedParameterNames(self) -> bool:
        """
        Report whether the model has fixed parameter names set.
        :return: Boolean indicating whether fixed parameter names were set. Also
            returns `true` if the number of corresponding variables is just zero.
        """
        return _amici.Model_hasFixedParameterNames(self)

    def getFixedParameterNames(self) -> Sequence[str]:
        """
        Get names of the fixed model parameters.
        :return: Fixed parameter names
        """
        return _amici.Model_getFixedParameterNames(self)

    def hasObservableNames(self) -> bool:
        """
        Report whether the model has observable names set.
        :return: Boolean indicating whether observable names were set. Also
            returns `true` if the number of corresponding variables is just zero.
        """
        return _amici.Model_hasObservableNames(self)

    def getObservableNames(self) -> Sequence[str]:
        """
        Get names of the observables.
        :return: Observable names
        """
        return _amici.Model_getObservableNames(self)

    def hasExpressionNames(self) -> bool:
        """
        Report whether the model has expression names set.
        :return: Boolean indicating whether expression names were set. Also
            returns `true` if the number of corresponding variables is just zero.
        """
        return _amici.Model_hasExpressionNames(self)

    def getExpressionNames(self) -> Sequence[str]:
        """
        Get names of the expressions.
        :return: Expression names
        """
        return _amici.Model_getExpressionNames(self)

    def hasParameterIds(self) -> bool:
        """
        Report whether the model has parameter IDs set.
        :return: Boolean indicating whether parameter IDs were set. Also returns
            `true` if the number of corresponding variables is just zero.
        """
        return _amici.Model_hasParameterIds(self)

    def getParameterIds(self) -> Sequence[str]:
        """
        Get IDs of the model parameters.
        :return: Parameter IDs
        """
        return _amici.Model_getParameterIds(self)

    def hasStateIds(self) -> bool:
        """
        Report whether the model has state IDs set.
        :return: Boolean indicating whether state IDs were set. Also returns
            `true` if the number of corresponding variables is just zero.
        """
        return _amici.Model_hasStateIds(self)

    def getStateIds(self) -> Sequence[str]:
        """
        Get IDs of the model states.
        :return: State IDs
        """
        return _amici.Model_getStateIds(self)

    def getStateIdsSolver(self) -> Sequence[str]:
        """
        Get IDs of the solver states.
        :return: State IDs
        """
        return _amici.Model_getStateIdsSolver(self)

    def hasFixedParameterIds(self) -> bool:
        """
        Report whether the model has fixed parameter IDs set.
        :return: Boolean indicating whether fixed parameter IDs were set. Also
            returns `true` if the number of corresponding variables is just zero.
        """
        return _amici.Model_hasFixedParameterIds(self)

    def getFixedParameterIds(self) -> Sequence[str]:
        """
        Get IDs of the fixed model parameters.
        :return: Fixed parameter IDs
        """
        return _amici.Model_getFixedParameterIds(self)

    def hasObservableIds(self) -> bool:
        """
        Report whether the model has observable IDs set.
        :return: Boolean indicating whether observable ids were set. Also returns
            `true` if the number of corresponding variables is just zero.
        """
        return _amici.Model_hasObservableIds(self)

    def getObservableIds(self) -> Sequence[str]:
        """
        Get IDs of the observables.
        :return: Observable IDs
        """
        return _amici.Model_getObservableIds(self)

    def hasExpressionIds(self) -> bool:
        """
        Report whether the model has expression IDs set.
        :return: Boolean indicating whether expression ids were set. Also returns
            `true` if the number of corresponding variables is just zero.
        """
        return _amici.Model_hasExpressionIds(self)

    def getExpressionIds(self) -> Sequence[str]:
        """
        Get IDs of the expression.
        :return: Expression IDs
        """
        return _amici.Model_getExpressionIds(self)

    def hasQuadraticLLH(self) -> bool:
        """
        Checks whether the defined noise model is gaussian, i.e., the nllh
        is quadratic
        :return: boolean flag
        """
        return _amici.Model_hasQuadraticLLH(self)

    def getTimepoints(self) -> Sequence[float]:
        """
        Get the timepoint vector.
        :return: Timepoint vector
        """
        return _amici.Model_getTimepoints(self)

    def getTimepoint(self, it: int) -> 'float':
        """
        Get simulation timepoint for time index `it`.
        :param it: Time index
        :return: Timepoint
        """
        return _amici.Model_getTimepoint(self, it)

    def setTimepoints(self, ts: Sequence[float]):
        """
        Set the timepoint vector.
        :param ts: New timepoint vector
        """
        return _amici.Model_setTimepoints(self, ts)

    def t0(self) -> 'float':
        """
        Get simulation start time.
        :return: Simulation start time
        """
        return _amici.Model_t0(self)

    def setT0(self, t0: 'float'):
        """
        Set simulation start time.

        Output timepoints are absolute timepoints, independent of
        :math:`t_{0}`.
        For output timepoints :math:`t <  t_{0}`, the initial state will be
        returned.

        :param t0: Simulation start time
        """
        return _amici.Model_setT0(self, t0)

    def getStateIsNonNegative(self) -> Sequence[bool]:
        """
        Get flags indicating whether states should be treated as
        non-negative.
        :return: Vector of flags
        """
        return _amici.Model_getStateIsNonNegative(self)

    def setStateIsNonNegative(self, stateIsNonNegative: Sequence[bool]):
        """
        Set flags indicating whether states should be treated as
        non-negative.
        :param stateIsNonNegative: Vector of flags
        """
        return _amici.Model_setStateIsNonNegative(self, stateIsNonNegative)

    def setAllStatesNonNegative(self):
        """
        Set flags indicating that all states should be treated as
        non-negative.
        """
        return _amici.Model_setAllStatesNonNegative(self)

    def setMinimumSigmaResiduals(self, min_sigma: 'float'):
        """
        Sets the estimated lower boundary for sigma_y. When
        :meth:`setAddSigmaResiduals` is activated, this lower boundary must
        ensure that log(sigma) + min_sigma > 0.
        :param min_sigma: lower boundary
        """
        return _amici.Model_setMinimumSigmaResiduals(self, min_sigma)

    def getMinimumSigmaResiduals(self) -> 'float':
        """
        Gets the specified estimated lower boundary for sigma_y.
        :return: lower boundary
        """
        return _amici.Model_getMinimumSigmaResiduals(self)

    def setAddSigmaResiduals(self, sigma_res: bool):
        """
        Specifies whether residuals should be added to account for
        parameter dependent sigma.

        If set to true, additional residuals of the form :math:`\\sqrt{\\log(\\sigma) +C}` will be added. This enables least-squares optimization for
        variables with Gaussian noise assumption and parameter dependent standard
        deviation sigma. The constant :math:`C` can be set via
        :meth:`setMinimumSigmaResiduals`.

        :param sigma_res: if true, additional residuals are added
        """
        return _amici.Model_setAddSigmaResiduals(self, sigma_res)

    def getAddSigmaResiduals(self) -> bool:
        """
        Checks whether residuals should be added to account for parameter
        dependent sigma.
        :return: sigma_res
        """
        return _amici.Model_getAddSigmaResiduals(self)

    def getParameterList(self) -> Sequence[int]:
        """
        Get the list of parameters for which sensitivities are computed.
        :return: List of parameter indices
        """
        return _amici.Model_getParameterList(self)

    def plist(self, pos: int) -> int:
        """
        Get entry in parameter list by index.
        :param pos: Index in sensitivity parameter list
        :return: Index in parameter list
        """
        return _amici.Model_plist(self, pos)

    def setParameterList(self, plist: Sequence[int]):
        """
        Set the list of parameters for which sensitivities are to be
        computed.

        NOTE: Resets initial state sensitivities.

        :param plist: List of parameter indices
        """
        return _amici.Model_setParameterList(self, plist)

    def getInitialStates(self) -> Sequence[float]:
        """
        Get the initial states.
        :return: Initial state vector
        """
        return _amici.Model_getInitialStates(self)

    def setInitialStates(self, x0: Sequence[float]):
        """
        Set the initial states.
        :param x0: Initial state vector
        """
        return _amici.Model_setInitialStates(self, x0)

    def hasCustomInitialStates(self) -> bool:
        """
        Return whether custom initial states have been set.
        :return: `true` if has custom initial states, otherwise `false`
        """
        return _amici.Model_hasCustomInitialStates(self)

    def getInitialStateSensitivities(self) -> Sequence[float]:
        """
        Get the initial states sensitivities.
        :return: vector of initial state sensitivities
        """
        return _amici.Model_getInitialStateSensitivities(self)

    def setInitialStateSensitivities(self, sx0: Sequence[float]):
        """
        Set the initial state sensitivities.
        :param sx0: vector of initial state sensitivities with chainrule applied.
            This could be a slice of ReturnData::sx or ReturnData::sx0
        """
        return _amici.Model_setInitialStateSensitivities(self, sx0)

    def hasCustomInitialStateSensitivities(self) -> bool:
        """
        Return whether custom initial state sensitivities have been set.
        :return: `true` if has custom initial state sensitivities, otherwise
            `false`.
        """
        return _amici.Model_hasCustomInitialStateSensitivities(self)

    def setUnscaledInitialStateSensitivities(self, sx0: Sequence[float]):
        """
        Set the initial state sensitivities.
        :param sx0: Vector of initial state sensitivities without chainrule
            applied. This could be the readin from a `model.sx0data` saved to HDF5.
        """
        return _amici.Model_setUnscaledInitialStateSensitivities(self, sx0)

    def setSteadyStateComputationMode(self, mode: int):
        """
        Set the mode how steady state is computed in the steadystate
        simulation.
        :param mode: Steadystate computation mode
        """
        return _amici.Model_setSteadyStateComputationMode(self, mode)

    def getSteadyStateComputationMode(self) -> int:
        """
        Gets the mode how steady state is computed in the steadystate
        simulation.
        :return: Mode
        """
        return _amici.Model_getSteadyStateComputationMode(self)

    def setSteadyStateSensitivityMode(self, mode: 'SteadyStateSensitivityMode'):
        """
        Set the mode how sensitivities are computed in the steadystate
        simulation.
        :param mode: Steadystate sensitivity mode
        """
        return _amici.Model_setSteadyStateSensitivityMode(self, mode)

    def getSteadyStateSensitivityMode(self) -> 'SteadyStateSensitivityMode':
        """
        Gets the mode how sensitivities are computed in the steadystate
        simulation.
        :return: Mode
        """
        return _amici.Model_getSteadyStateSensitivityMode(self)

    def setReinitializeFixedParameterInitialStates(self, flag: bool):
        """
        Set whether initial states depending on fixed parameters are to be
        reinitialized after preequilibration and presimulation.
        :param flag: Fixed parameters reinitialized?
        """
        return _amici.Model_setReinitializeFixedParameterInitialStates(self, flag)

    def getReinitializeFixedParameterInitialStates(self) -> bool:
        """
        Get whether initial states depending on fixedParameters are to be
        reinitialized after preequilibration and presimulation.
        :return: flag `true` / `false`
        """
        return _amici.Model_getReinitializeFixedParameterInitialStates(self)

    def requireSensitivitiesForAllParameters(self):
        """
        Require computation of sensitivities for all parameters p [0..np[
        in natural order.

        NOTE: Resets initial state sensitivities.
        """
        return _amici.Model_requireSensitivitiesForAllParameters(self)

    def getObservableScaling(self, iy: int) -> int:
        """
        Get scaling type for observable
        :param iy: observable index
        :return: scaling type
        """
        return _amici.Model_getObservableScaling(self, iy)

    def setAlwaysCheckFinite(self, alwaysCheck: bool):
        """
        Set whether the result of every call to `Model::f*` should be
        checked for finiteness.
        :param alwaysCheck:
        """
        return _amici.Model_setAlwaysCheckFinite(self, alwaysCheck)

    def getAlwaysCheckFinite(self) -> bool:
        """
        Get setting of whether the result of every call to `Model::f*`
        should be checked for finiteness.
        :return: that
        """
        return _amici.Model_getAlwaysCheckFinite(self)

    def setReinitializationStateIdxs(self, idxs: Sequence[int]):
        """
        Set indices of states to be reinitialized based on provided
        constants / fixed parameters
        :param idxs: Array of state indices
        """
        return _amici.Model_setReinitializationStateIdxs(self, idxs)

    def getReinitializationStateIdxs(self) -> Sequence[int]:
        """
        Return indices of states to be reinitialized based on provided
        constants / fixed parameters
        :return: Those indices.
        """
        return _amici.Model_getReinitializationStateIdxs(self)
    pythonGenerated = property(_amici.Model_pythonGenerated_get, _amici.Model_pythonGenerated_set, doc=' Flag indicating Matlab- or Python-based model generation')

    def get_trigger_timepoints(self) -> Sequence[float]:
        """
        Get trigger times for events that don't require root-finding.

        :return: List of unique trigger points for events that don't require
            root-finding (i.e. that trigger at predetermined timepoints),
            in ascending order.
        """
        return _amici.Model_get_trigger_timepoints(self)

    def get_steadystate_mask(self) -> Sequence[float]:
        """
        Get steady-state mask as std::vector.

        See `set_steadystate_mask` for details.

        :return: Steady-state mask
        """
        return _amici.Model_get_steadystate_mask(self)

    def set_steadystate_mask(self, mask: Sequence[float]):
        """
        Set steady-state mask.

        The mask is used to exclude certain state variables from the steady-state
        convergence check. Positive values indicate that the corresponding state
        variable should be included in the convergence check, while non-positive
        values indicate that the corresponding state variable should be excluded.
        An empty mask is interpreted as including all state variables.

        :param mask: Mask of length `nx_solver`.
        """
        return _amici.Model_set_steadystate_mask(self, mask)
    o2mode = property(_amici.Model_o2mode_get, _amici.Model_o2mode_set, doc='\n    Flag indicating whether for\n    `amici::Solver::sensi_` == `amici::SensitivityOrder::second`\n    directional or full second order derivative will be computed\n    ')
    idlist = property(_amici.Model_idlist_get, _amici.Model_idlist_set, doc=' Flag array for DAE equations')
    logger = property(_amici.Model_logger_get, _amici.Model_logger_set, doc=' Logger')
    state_independent_events_ = property(_amici.Model_state_independent_events__get, _amici.Model_state_independent_events__set, doc="\n    Map of trigger timepoints to event indices for events that don't\n    require root-finding.\n    ")

    def __deepcopy__(self, memo):
        return self.clone()

    def setParameterScale(self, *args):
        return _amici.Model_setParameterScale(self, *args)
_amici.Model_swigregister(Model)
model_quantity_to_str = cvar.model_quantity_to_str

def __eq__(*args):
    return _amici.__eq__(*args)

class Model_ODE(Model):
    """
    The Model class represents an AMICI ODE model.

    The model does not contain any data, but represents the state
    of the model at a specific time t. The states must not always be
    in sync, but may be updated asynchronously.
    """
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError('No constructor defined - class is abstract')
    __repr__ = _swig_repr

    def getSolver(self):
        return _amici.Model_ODE_getSolver(self)
    __swig_destroy__ = _amici.delete_Model_ODE
_amici.Model_ODE_swigregister(Model_ODE)

class Model_DAE(Model):
    """
    The Model class represents an AMICI DAE model.

    The model does not contain any data, but represents the state
    of the model at a specific time t. The states must not always be
    in sync, but may be updated asynchronously.
    """
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError('No constructor defined - class is abstract')
    __repr__ = _swig_repr

    def getSolver(self):
        return _amici.Model_DAE_getSolver(self)
    __swig_destroy__ = _amici.delete_Model_DAE
_amici.Model_DAE_swigregister(Model_DAE)
LogSeverity_error = _amici.LogSeverity_error
LogSeverity_warning = _amici.LogSeverity_warning
LogSeverity_debug = _amici.LogSeverity_debug

class LogItem(object):
    """A log item."""
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        *Overload 1:*

        Default ctor.

        |

        *Overload 2:*

        Construct a LogItem
        :type severity: int
        :param severity:
        :type identifier: str
        :param identifier:
        :type message: str
        :param message:
        """
        _amici.LogItem_swiginit(self, _amici.new_LogItem(*args))
    severity = property(_amici.LogItem_severity_get, _amici.LogItem_severity_set, doc=' Severity level')
    identifier = property(_amici.LogItem_identifier_get, _amici.LogItem_identifier_set, doc=' Short identifier for the logged event')
    message = property(_amici.LogItem_message_get, _amici.LogItem_message_set, doc=' A more detailed and readable message')

    def __repr__(self):
        return f'{self.__class__.__name__}(severity={self.severity}, identifier={self.identifier!r}, message={self.message!r})'
    __swig_destroy__ = _amici.delete_LogItem
_amici.LogItem_swigregister(LogItem)

class ReturnData(ModelDimensions):
    """
    Stores all data to be returned by amici::runAmiciSimulation.

    NOTE: multi-dimensional arrays are stored in row-major order (C-style)
    """
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        *Overload 1:*

        Default constructor

        |

        *Overload 2:*

        Constructor
        :type ts: DoubleVector
        :param ts: see amici::SimulationParameters::ts
        :type model_dimensions: :py:class:`ModelDimensions`
        :param model_dimensions: Model dimensions
        :type nplist: int
        :param nplist: see amici::ModelDimensions::nplist
        :type nmaxevent: int
        :param nmaxevent: see amici::ModelDimensions::nmaxevent
        :type nt: int
        :param nt: see amici::ModelDimensions::nt
        :type newton_maxsteps: int
        :param newton_maxsteps: see amici::Solver::newton_maxsteps
        :type pscale: ParameterScalingVector
        :param pscale: see amici::SimulationParameters::pscale
        :type o2mode: int
        :param o2mode: see amici::SimulationParameters::o2mode
        :type sensi: SensitivityOrder
        :param sensi: see amici::Solver::sensi
        :type sensi_meth: SensitivityMethod
        :param sensi_meth: see amici::Solver::sensi_meth
        :type rdrm: RDataReporting
        :param rdrm: see amici::Solver::rdata_reporting
        :type quadratic_llh: boolean
        :param quadratic_llh: whether model defines a quadratic nllh and
            computing res, sres and FIM makes sense
        :type sigma_res: boolean
        :param sigma_res: indicates whether additional residuals are to be added
            for each sigma
        :type sigma_offset: float
        :param sigma_offset: offset to ensure real-valuedness of sigma residuals

        |

        *Overload 3:*

        constructor that uses information from model and solver to
        appropriately initialize fields
        :type solver: :py:class:`Solver`
        :param solver: solver instance
        :type model: :py:class:`Model`
        :param model: model instance
        """
        _amici.ReturnData_swiginit(self, _amici.new_ReturnData(*args))
    __swig_destroy__ = _amici.delete_ReturnData
    id = property(_amici.ReturnData_id_get, _amici.ReturnData_id_set, doc='Arbitrary (not necessarily unique) identifier.')
    ts = property(_amici.ReturnData_ts_get, _amici.ReturnData_ts_set, doc='timepoints (shape `nt`)')
    xdot = property(_amici.ReturnData_xdot_get, _amici.ReturnData_xdot_set, doc=' time derivative (shape `nx`) evaluated at `t_last`.')
    J = property(_amici.ReturnData_J_get, _amici.ReturnData_J_set, doc='\n    Jacobian of differential equation right hand side (shape `nx` x `nx`,\n    row-major) evaluated at `t_last`.\n    ')
    w = property(_amici.ReturnData_w_get, _amici.ReturnData_w_set, doc='\n    w data from the model (recurring terms in xdot, for imported SBML models\n    from python, this contains the flux vector) (shape `nt` x `nw`, row\n    major)\n    ')
    z = property(_amici.ReturnData_z_get, _amici.ReturnData_z_set, doc=' event output (shape `nmaxevent` x `nz`, row-major)')
    sigmaz = property(_amici.ReturnData_sigmaz_get, _amici.ReturnData_sigmaz_set, doc='\n    event output sigma standard deviation (shape `nmaxevent` x `nz`,\n    row-major)\n    ')
    sz = property(_amici.ReturnData_sz_get, _amici.ReturnData_sz_set, doc='\n    parameter derivative of event output\n    (shape `nmaxevent` x `nplist` x `nz`, row-major)\n    ')
    ssigmaz = property(_amici.ReturnData_ssigmaz_get, _amici.ReturnData_ssigmaz_set, doc='\n    parameter derivative of event output standard deviation\n    (shape `nmaxevent` x `nplist` x `nz`, row-major)\n    ')
    rz = property(_amici.ReturnData_rz_get, _amici.ReturnData_rz_set, doc=' event trigger output (shape `nmaxevent` x `nz`, row-major)')
    srz = property(_amici.ReturnData_srz_get, _amici.ReturnData_srz_set, doc='\n    parameter derivative of event trigger output\n    (shape `nmaxevent` x `nplist` x `nz`, row-major)\n    ')
    s2rz = property(_amici.ReturnData_s2rz_get, _amici.ReturnData_s2rz_set, doc='\n    second-order parameter derivative of event trigger output (shape\n    `nmaxevent` x `nztrue` x `nplist` x `nplist`, row-major)\n    ')
    x = property(_amici.ReturnData_x_get, _amici.ReturnData_x_set, doc=' state (shape `nt` x `nx`, row-major)')
    sx = property(_amici.ReturnData_sx_get, _amici.ReturnData_sx_set, doc='parameter derivative of state (shape `nt` x `nplist` x `nx`, row-major)')
    y = property(_amici.ReturnData_y_get, _amici.ReturnData_y_set, doc=' observable (shape `nt` x `ny`, row-major)')
    sigmay = property(_amici.ReturnData_sigmay_get, _amici.ReturnData_sigmay_set, doc=' observable standard deviation (shape `nt` x `ny`, row-major)')
    sy = property(_amici.ReturnData_sy_get, _amici.ReturnData_sy_set, doc='\n    parameter derivative of observable (shape `nt` x `nplist` x `ny`,\n    row-major)\n    ')
    ssigmay = property(_amici.ReturnData_ssigmay_get, _amici.ReturnData_ssigmay_set, doc='\n    parameter derivative of observable standard deviation\n    (shape `nt` x `nplist` x `ny`, row-major)\n    ')
    res = property(_amici.ReturnData_res_get, _amici.ReturnData_res_set, doc=' observable (shape `nt*ny`, row-major)')
    sres = property(_amici.ReturnData_sres_get, _amici.ReturnData_sres_set, doc='parameter derivative of residual (shape `nt*ny` x `nplist`, row-major)')
    FIM = property(_amici.ReturnData_FIM_get, _amici.ReturnData_FIM_set, doc=' fisher information matrix (shape `nplist` x `nplist`, row-major)')
    numsteps = property(_amici.ReturnData_numsteps_get, _amici.ReturnData_numsteps_set, doc=' number of integration steps forward problem (shape `nt`)')
    numstepsB = property(_amici.ReturnData_numstepsB_get, _amici.ReturnData_numstepsB_set, doc=' number of integration steps backward problem (shape `nt`)')
    numrhsevals = property(_amici.ReturnData_numrhsevals_get, _amici.ReturnData_numrhsevals_set, doc=' number of right hand side evaluations forward problem (shape `nt`)')
    numrhsevalsB = property(_amici.ReturnData_numrhsevalsB_get, _amici.ReturnData_numrhsevalsB_set, doc=' number of right hand side evaluations backward problem (shape `nt`)')
    numerrtestfails = property(_amici.ReturnData_numerrtestfails_get, _amici.ReturnData_numerrtestfails_set, doc=' number of error test failures forward problem (shape `nt`)')
    numerrtestfailsB = property(_amici.ReturnData_numerrtestfailsB_get, _amici.ReturnData_numerrtestfailsB_set, doc=' number of error test failures backward problem (shape `nt`)')
    numnonlinsolvconvfails = property(_amici.ReturnData_numnonlinsolvconvfails_get, _amici.ReturnData_numnonlinsolvconvfails_set, doc='number of linear solver convergence failures forward problem (shape `nt`)')
    numnonlinsolvconvfailsB = property(_amici.ReturnData_numnonlinsolvconvfailsB_get, _amici.ReturnData_numnonlinsolvconvfailsB_set, doc='\n    number of linear solver convergence failures backward problem (shape\n    `nt`)\n    ')
    order = property(_amici.ReturnData_order_get, _amici.ReturnData_order_set, doc=' employed order forward problem (shape `nt`)')
    cpu_time = property(_amici.ReturnData_cpu_time_get, _amici.ReturnData_cpu_time_set, doc='\n    computation time of forward solve [ms]\n\n    .. warning::\n         If AMICI was built without boost, this tracks the CPU-time of the\n         current process. Therefore, in a multi-threaded context, this value\n         may be incorrect.\n    ')
    cpu_timeB = property(_amici.ReturnData_cpu_timeB_get, _amici.ReturnData_cpu_timeB_set, doc='\n    computation time of backward solve [ms]\n\n    .. warning::\n         If AMICI was built without boost, this tracks the CPU-time of the\n         current process. Therefore, in a multi-threaded context, this value\n         may be incorrect.\n    ')
    cpu_time_total = property(_amici.ReturnData_cpu_time_total_get, _amici.ReturnData_cpu_time_total_set, doc='\n    total CPU time from entering runAmiciSimulation until exiting [ms]\n\n    .. warning::\n         If AMICI was built without boost, this tracks the CPU-time of the\n         current process. Therefore, in a multi-threaded context, this value\n         may be incorrect.\n    ')
    preeq_status = property(_amici.ReturnData_preeq_status_get, _amici.ReturnData_preeq_status_set, doc=' flags indicating success of steady state solver (preequilibration)')
    preeq_cpu_time = property(_amici.ReturnData_preeq_cpu_time_get, _amici.ReturnData_preeq_cpu_time_set, doc='\n    computation time of the steady state solver [ms]\n    (preequilibration)\n\n    .. warning::\n         If AMICI was built without boost, this tracks the CPU-time of the\n         current process. Therefore, in a multi-threaded context, this value\n         may be incorrect.\n    ')
    preeq_cpu_timeB = property(_amici.ReturnData_preeq_cpu_timeB_get, _amici.ReturnData_preeq_cpu_timeB_set, doc='\n    computation time of the steady state solver of the backward\n    problem [ms] (preequilibration)\n\n    .. warning::\n         If AMICI was built without boost, this tracks the CPU-time of the\n         current process. Therefore, in a multi-threaded context, this value\n         may be incorrect.\n    ')
    posteq_status = property(_amici.ReturnData_posteq_status_get, _amici.ReturnData_posteq_status_set, doc=' flags indicating success of steady state solver  (postequilibration)')
    posteq_cpu_time = property(_amici.ReturnData_posteq_cpu_time_get, _amici.ReturnData_posteq_cpu_time_set, doc='\n    computation time of the steady state solver [ms]\n    (postequilibration)\n\n    .. warning::\n         If AMICI was built without boost, this tracks the CPU-time of the\n         current process. Therefore, in a multi-threaded context, this value\n         may be incorrect.\n    ')
    posteq_cpu_timeB = property(_amici.ReturnData_posteq_cpu_timeB_get, _amici.ReturnData_posteq_cpu_timeB_set, doc='\n    computation time of the steady state solver of the backward\n    problem [ms] (postequilibration)\n\n    .. warning::\n         If AMICI was built without boost, this tracks the CPU-time of the\n         current process. Therefore, in a multi-threaded context, this value\n         may be incorrect.\n    ')
    preeq_numsteps = property(_amici.ReturnData_preeq_numsteps_get, _amici.ReturnData_preeq_numsteps_set, doc='\n    number of Newton steps for steady state problem (preequilibration)\n    [newton, simulation, newton] (length = 3)\n    ')
    preeq_numstepsB = property(_amici.ReturnData_preeq_numstepsB_get, _amici.ReturnData_preeq_numstepsB_set, doc='\n    number of simulation steps for adjoint steady state problem\n    (preequilibration) [== 0 if analytical solution worked, > 0 otherwise]\n    ')
    posteq_numsteps = property(_amici.ReturnData_posteq_numsteps_get, _amici.ReturnData_posteq_numsteps_set, doc='\n    number of Newton steps for steady state problem (preequilibration)\n    [newton, simulation, newton] (shape `3`) (postequilibration)\n    ')
    posteq_numstepsB = property(_amici.ReturnData_posteq_numstepsB_get, _amici.ReturnData_posteq_numstepsB_set, doc='\n    number of simulation steps for adjoint steady state problem\n    (postequilibration) [== 0 if analytical solution worked, > 0 otherwise]\n    ')
    preeq_t = property(_amici.ReturnData_preeq_t_get, _amici.ReturnData_preeq_t_set, doc='time when steadystate was reached via simulation (preequilibration)')
    preeq_wrms = property(_amici.ReturnData_preeq_wrms_get, _amici.ReturnData_preeq_wrms_set, doc='\n    weighted root-mean-square of the rhs when steadystate\n    was reached (preequilibration)\n    ')
    posteq_t = property(_amici.ReturnData_posteq_t_get, _amici.ReturnData_posteq_t_set, doc='time when steadystate was reached via simulation (postequilibration)')
    posteq_wrms = property(_amici.ReturnData_posteq_wrms_get, _amici.ReturnData_posteq_wrms_set, doc='\n    weighted root-mean-square of the rhs when steadystate\n    was reached (postequilibration)\n    ')
    x0 = property(_amici.ReturnData_x0_get, _amici.ReturnData_x0_set, doc=' initial state (shape `nx`)')
    x_ss = property(_amici.ReturnData_x_ss_get, _amici.ReturnData_x_ss_set, doc=' preequilibration steady state (shape `nx`)')
    sx0 = property(_amici.ReturnData_sx0_get, _amici.ReturnData_sx0_set, doc=' initial sensitivities (shape `nplist` x `nx`, row-major)')
    sx_ss = property(_amici.ReturnData_sx_ss_get, _amici.ReturnData_sx_ss_set, doc='\n    preequilibration sensitivities\n    (shape `nplist` x `nx`, row-major)\n    ')
    llh = property(_amici.ReturnData_llh_get, _amici.ReturnData_llh_set, doc=' log-likelihood value')
    chi2 = property(_amici.ReturnData_chi2_get, _amici.ReturnData_chi2_set, doc=' :math:`\\chi^2` value')
    sllh = property(_amici.ReturnData_sllh_get, _amici.ReturnData_sllh_set, doc=' parameter derivative of log-likelihood (shape `nplist`)')
    s2llh = property(_amici.ReturnData_s2llh_get, _amici.ReturnData_s2llh_set, doc='\n    second-order parameter derivative of log-likelihood\n    (shape `nJ-1` x `nplist`, row-major)\n    ')
    status = property(_amici.ReturnData_status_get, _amici.ReturnData_status_set, doc='\n    Simulation status code.\n\n    One of:\n\n    * AMICI_SUCCESS, indicating successful simulation\n    * AMICI_MAX_TIME_EXCEEDED, indicating that the simulation did not finish\n      within the allowed time (see Solver.{set,get}MaxTime)\n    * AMICI_ERROR, indicating that some error occurred during simulation\n      (a more detailed error message will have been printed).\n    * AMICI_NOT_RUN, if no simulation was started\n    ')
    nx = property(_amici.ReturnData_nx_get, _amici.ReturnData_nx_set, doc=' number of states (alias `nx_rdata`, kept for backward compatibility)')
    nxtrue = property(_amici.ReturnData_nxtrue_get, _amici.ReturnData_nxtrue_set, doc='\n    number of states in the unaugmented system\n    (alias nxtrue_rdata, kept for backward compatibility)\n    ')
    nplist = property(_amici.ReturnData_nplist_get, _amici.ReturnData_nplist_set, doc=' number of parameter for which sensitivities were requested')
    nmaxevent = property(_amici.ReturnData_nmaxevent_get, _amici.ReturnData_nmaxevent_set, doc=' maximal number of occurring events (for every event type)')
    nt = property(_amici.ReturnData_nt_get, _amici.ReturnData_nt_set, doc=' number of considered timepoints')
    newton_maxsteps = property(_amici.ReturnData_newton_maxsteps_get, _amici.ReturnData_newton_maxsteps_set, doc=' maximal number of newton iterations for steady state calculation')
    pscale = property(_amici.ReturnData_pscale_get, _amici.ReturnData_pscale_set, doc=' scaling of parameterization')
    o2mode = property(_amici.ReturnData_o2mode_get, _amici.ReturnData_o2mode_set, doc=' flag indicating whether second-order sensitivities were requested')
    sensi = property(_amici.ReturnData_sensi_get, _amici.ReturnData_sensi_set, doc=' sensitivity order')
    sensi_meth = property(_amici.ReturnData_sensi_meth_get, _amici.ReturnData_sensi_meth_set, doc=' sensitivity method')
    rdata_reporting = property(_amici.ReturnData_rdata_reporting_get, _amici.ReturnData_rdata_reporting_set, doc=' reporting mode')
    sigma_res = property(_amici.ReturnData_sigma_res_get, _amici.ReturnData_sigma_res_set, doc='\n     boolean indicating whether residuals for standard deviations have been\n    added\n    ')
    messages = property(_amici.ReturnData_messages_get, _amici.ReturnData_messages_set, doc=' log messages')
    t_last = property(_amici.ReturnData_t_last_get, _amici.ReturnData_t_last_set, doc=' The final internal time of the solver.')
_amici.ReturnData_swigregister(ReturnData)

def runAmiciSimulation(solver: 'Solver', edata: 'ExpData', model: 'Model', rethrow: bool=False) -> 'ReturnData':
    """
    Core integration routine. Initializes the solver and runs the forward
    and backward problem.

    :param solver: Solver instance
    :param edata: pointer to experimental data object
    :param model: model specification object
    :param rethrow: rethrow integration exceptions?
    :return: rdata pointer to return data object
    """
    return _amici.runAmiciSimulation(solver, edata, model, rethrow)

def runAmiciSimulations(solver: 'Solver', edatas: 'ExpDataPtrVector', model: 'Model', failfast: bool, num_threads: int) -> 'Iterable[ReturnData]':
    """
    Same as runAmiciSimulation, but for multiple ExpData instances. When
    compiled with OpenMP support, this function runs multi-threaded.

    :param solver: Solver instance
    :param edatas: experimental data objects
    :param model: model specification object
    :param failfast: flag to allow early termination
    :param num_threads: number of threads for parallel execution
    :return: vector of pointers to return data objects
    """
    return _amici.runAmiciSimulations(solver, edatas, model, failfast, num_threads)

def simulation_status_to_str(status: int) -> 'str':
    """
    Get the string representation of the given simulation status code
    (see ReturnData::status).
    :param status: Status code
    :return: Name of the variable representing this status code.
    """
    return _amici.simulation_status_to_str(status)

class ExpDataPtrVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self):
        return _amici.ExpDataPtrVector_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _amici.ExpDataPtrVector___nonzero__(self)

    def __bool__(self):
        return _amici.ExpDataPtrVector___bool__(self)

    def __len__(self):
        return _amici.ExpDataPtrVector___len__(self)

    def __getslice__(self, i, j):
        return _amici.ExpDataPtrVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _amici.ExpDataPtrVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _amici.ExpDataPtrVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _amici.ExpDataPtrVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _amici.ExpDataPtrVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _amici.ExpDataPtrVector___setitem__(self, *args)

    def pop(self):
        return _amici.ExpDataPtrVector_pop(self)

    def append(self, x):
        return _amici.ExpDataPtrVector_append(self, x)

    def empty(self):
        return _amici.ExpDataPtrVector_empty(self)

    def size(self):
        return _amici.ExpDataPtrVector_size(self)

    def swap(self, v):
        return _amici.ExpDataPtrVector_swap(self, v)

    def begin(self):
        return _amici.ExpDataPtrVector_begin(self)

    def end(self):
        return _amici.ExpDataPtrVector_end(self)

    def rbegin(self):
        return _amici.ExpDataPtrVector_rbegin(self)

    def rend(self):
        return _amici.ExpDataPtrVector_rend(self)

    def clear(self):
        return _amici.ExpDataPtrVector_clear(self)

    def get_allocator(self):
        return _amici.ExpDataPtrVector_get_allocator(self)

    def pop_back(self):
        return _amici.ExpDataPtrVector_pop_back(self)

    def erase(self, *args):
        return _amici.ExpDataPtrVector_erase(self, *args)

    def __init__(self, *args):
        _amici.ExpDataPtrVector_swiginit(self, _amici.new_ExpDataPtrVector(*args))

    def push_back(self, x):
        return _amici.ExpDataPtrVector_push_back(self, x)

    def front(self):
        return _amici.ExpDataPtrVector_front(self)

    def back(self):
        return _amici.ExpDataPtrVector_back(self)

    def assign(self, n, x):
        return _amici.ExpDataPtrVector_assign(self, n, x)

    def resize(self, *args):
        return _amici.ExpDataPtrVector_resize(self, *args)

    def insert(self, *args):
        return _amici.ExpDataPtrVector_insert(self, *args)

    def reserve(self, n):
        return _amici.ExpDataPtrVector_reserve(self, n)

    def capacity(self):
        return _amici.ExpDataPtrVector_capacity(self)

    def __repr__(self):
        return self.this.__repr__()[:-1] + '; ' + repr(list(self)) + ' >'
    __swig_destroy__ = _amici.delete_ExpDataPtrVector
_amici.ExpDataPtrVector_swigregister(ExpDataPtrVector)

class LogItemVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self):
        return _amici.LogItemVector_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _amici.LogItemVector___nonzero__(self)

    def __bool__(self):
        return _amici.LogItemVector___bool__(self)

    def __len__(self):
        return _amici.LogItemVector___len__(self)

    def __getslice__(self, i, j):
        return _amici.LogItemVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _amici.LogItemVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _amici.LogItemVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _amici.LogItemVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _amici.LogItemVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _amici.LogItemVector___setitem__(self, *args)

    def pop(self):
        return _amici.LogItemVector_pop(self)

    def append(self, x):
        return _amici.LogItemVector_append(self, x)

    def empty(self):
        return _amici.LogItemVector_empty(self)

    def size(self):
        return _amici.LogItemVector_size(self)

    def swap(self, v):
        return _amici.LogItemVector_swap(self, v)

    def begin(self):
        return _amici.LogItemVector_begin(self)

    def end(self):
        return _amici.LogItemVector_end(self)

    def rbegin(self):
        return _amici.LogItemVector_rbegin(self)

    def rend(self):
        return _amici.LogItemVector_rend(self)

    def clear(self):
        return _amici.LogItemVector_clear(self)

    def get_allocator(self):
        return _amici.LogItemVector_get_allocator(self)

    def pop_back(self):
        return _amici.LogItemVector_pop_back(self)

    def erase(self, *args):
        return _amici.LogItemVector_erase(self, *args)

    def __init__(self, *args):
        _amici.LogItemVector_swiginit(self, _amici.new_LogItemVector(*args))

    def push_back(self, x):
        return _amici.LogItemVector_push_back(self, x)

    def front(self):
        return _amici.LogItemVector_front(self)

    def back(self):
        return _amici.LogItemVector_back(self)

    def assign(self, n, x):
        return _amici.LogItemVector_assign(self, n, x)

    def resize(self, *args):
        return _amici.LogItemVector_resize(self, *args)

    def insert(self, *args):
        return _amici.LogItemVector_insert(self, *args)

    def reserve(self, n):
        return _amici.LogItemVector_reserve(self, n)

    def capacity(self):
        return _amici.LogItemVector_capacity(self)

    def __repr__(self):
        return self.this.__repr__()[:-1] + '; ' + repr(list(self)) + ' >'
    __swig_destroy__ = _amici.delete_LogItemVector
_amici.LogItemVector_swigregister(LogItemVector)

def parameterScalingFromIntVector(intVec):
    """
    Swig-Generated class, which, in contrast to other Vector
    classes, does not allow for simple interoperability with common
    Python types, but must be created using
    :func:`amici.amici.parameterScalingFromIntVector`
    """
    return _amici.parameterScalingFromIntVector(intVec)

class ParameterScalingVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self):
        return _amici.ParameterScalingVector_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _amici.ParameterScalingVector___nonzero__(self)

    def __bool__(self):
        return _amici.ParameterScalingVector___bool__(self)

    def __len__(self):
        return _amici.ParameterScalingVector___len__(self)

    def __getslice__(self, i, j):
        return _amici.ParameterScalingVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _amici.ParameterScalingVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _amici.ParameterScalingVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _amici.ParameterScalingVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _amici.ParameterScalingVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _amici.ParameterScalingVector___setitem__(self, *args)

    def pop(self):
        return _amici.ParameterScalingVector_pop(self)

    def append(self, x):
        return _amici.ParameterScalingVector_append(self, x)

    def empty(self):
        return _amici.ParameterScalingVector_empty(self)

    def size(self):
        return _amici.ParameterScalingVector_size(self)

    def swap(self, v):
        return _amici.ParameterScalingVector_swap(self, v)

    def begin(self):
        return _amici.ParameterScalingVector_begin(self)

    def end(self):
        return _amici.ParameterScalingVector_end(self)

    def rbegin(self):
        return _amici.ParameterScalingVector_rbegin(self)

    def rend(self):
        return _amici.ParameterScalingVector_rend(self)

    def clear(self):
        return _amici.ParameterScalingVector_clear(self)

    def get_allocator(self):
        return _amici.ParameterScalingVector_get_allocator(self)

    def pop_back(self):
        return _amici.ParameterScalingVector_pop_back(self)

    def erase(self, *args):
        return _amici.ParameterScalingVector_erase(self, *args)

    def __init__(self, *args):
        _amici.ParameterScalingVector_swiginit(self, _amici.new_ParameterScalingVector(*args))

    def push_back(self, x):
        return _amici.ParameterScalingVector_push_back(self, x)

    def front(self):
        return _amici.ParameterScalingVector_front(self)

    def back(self):
        return _amici.ParameterScalingVector_back(self)

    def assign(self, n, x):
        return _amici.ParameterScalingVector_assign(self, n, x)

    def resize(self, *args):
        return _amici.ParameterScalingVector_resize(self, *args)

    def insert(self, *args):
        return _amici.ParameterScalingVector_insert(self, *args)

    def reserve(self, n):
        return _amici.ParameterScalingVector_reserve(self, n)

    def capacity(self):
        return _amici.ParameterScalingVector_capacity(self)

    def __repr__(self):
        return self.this.__repr__()[:-1] + '; ' + repr(list(self)) + ' >'
    __swig_destroy__ = _amici.delete_ParameterScalingVector
_amici.ParameterScalingVector_swigregister(ParameterScalingVector)

def compiledWithOpenMP():
    """AMICI extension was compiled with OpenMP?"""
    return _amici.compiledWithOpenMP()
from enum import IntEnum

def enum(prefix):
    values = {k: v for k, v in globals().items() if k.startswith(prefix + '_')}
    values = {k[len(prefix) + 1:]: v for k, v in values.items()}
    return IntEnum(prefix, values)
ParameterScaling = enum('ParameterScaling')
ObservableScaling = enum('ObservableScaling')
SecondOrderMode = enum('SecondOrderMode')
SensitivityOrder = enum('SensitivityOrder')
SensitivityMethod = enum('SensitivityMethod')
LinearSolver = enum('LinearSolver')
InternalSensitivityMethod = enum('InternalSensitivityMethod')
InterpolationType = enum('InterpolationType')
LinearMultistepMethod = enum('LinearMultistepMethod')
NonlinearSolverIteration = enum('NonlinearSolverIteration')
SteadyStateComputationMode = enum('SteadyStateComputationMode')
SteadyStateSensitivityMode = enum('SteadyStateSensitivityMode')
SteadyStateStatus = enum('SteadyStateStatus')
NewtonDampingFactorMode = enum('NewtonDampingFactorMode')
FixedParameterContext = enum('FixedParameterContext')
RDataReporting = enum('RDataReporting')
Constraint = enum('Constraint')

class SteadyStateStatusVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self):
        return _amici.SteadyStateStatusVector_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _amici.SteadyStateStatusVector___nonzero__(self)

    def __bool__(self):
        return _amici.SteadyStateStatusVector___bool__(self)

    def __len__(self):
        return _amici.SteadyStateStatusVector___len__(self)

    def __getslice__(self, i, j):
        return _amici.SteadyStateStatusVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _amici.SteadyStateStatusVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _amici.SteadyStateStatusVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _amici.SteadyStateStatusVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _amici.SteadyStateStatusVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _amici.SteadyStateStatusVector___setitem__(self, *args)

    def pop(self):
        return _amici.SteadyStateStatusVector_pop(self)

    def append(self, x):
        return _amici.SteadyStateStatusVector_append(self, x)

    def empty(self):
        return _amici.SteadyStateStatusVector_empty(self)

    def size(self):
        return _amici.SteadyStateStatusVector_size(self)

    def swap(self, v):
        return _amici.SteadyStateStatusVector_swap(self, v)

    def begin(self):
        return _amici.SteadyStateStatusVector_begin(self)

    def end(self):
        return _amici.SteadyStateStatusVector_end(self)

    def rbegin(self):
        return _amici.SteadyStateStatusVector_rbegin(self)

    def rend(self):
        return _amici.SteadyStateStatusVector_rend(self)

    def clear(self):
        return _amici.SteadyStateStatusVector_clear(self)

    def get_allocator(self):
        return _amici.SteadyStateStatusVector_get_allocator(self)

    def pop_back(self):
        return _amici.SteadyStateStatusVector_pop_back(self)

    def erase(self, *args):
        return _amici.SteadyStateStatusVector_erase(self, *args)

    def __init__(self, *args):
        _amici.SteadyStateStatusVector_swiginit(self, _amici.new_SteadyStateStatusVector(*args))

    def push_back(self, x):
        return _amici.SteadyStateStatusVector_push_back(self, x)

    def front(self):
        return _amici.SteadyStateStatusVector_front(self)

    def back(self):
        return _amici.SteadyStateStatusVector_back(self)

    def assign(self, n, x):
        return _amici.SteadyStateStatusVector_assign(self, n, x)

    def resize(self, *args):
        return _amici.SteadyStateStatusVector_resize(self, *args)

    def insert(self, *args):
        return _amici.SteadyStateStatusVector_insert(self, *args)

    def reserve(self, n):
        return _amici.SteadyStateStatusVector_reserve(self, n)

    def capacity(self):
        return _amici.SteadyStateStatusVector_capacity(self)

    def __repr__(self):
        return self.this.__repr__()[:-1] + '; ' + repr(list(self)) + ' >'
    __swig_destroy__ = _amici.delete_SteadyStateStatusVector
_amici.SteadyStateStatusVector_swigregister(SteadyStateStatusVector)
AmiciModel = Union[Model, ModelPtr]
AmiciSolver = Union[Solver, SolverPtr]
AmiciExpData = Union[ExpData, ExpDataPtr]
AmiciReturnData = Union[ReturnData, ReturnDataPtr]
AmiciExpDataVector = Union[ExpDataPtrVector, Sequence[AmiciExpData]]

def _get_ptr(obj: AmiciModel | AmiciExpData | AmiciSolver | AmiciReturnData) -> Model | ExpData | Solver | ReturnData:
    """
    Convenience wrapper that returns the smart pointer pointee, if applicable

    :param obj:
        Potential smart pointer

    :returns:
        Non-smart pointer
    """
    if isinstance(obj, (ModelPtr, ExpDataPtr, SolverPtr, ReturnDataPtr)):
        return obj.get()
    return obj
__all__ = [x for x in dir(sys.modules[__name__]) if not x.startswith('_') and x not in {'np', 'sys', 'os', 'numpy', 'IntEnum', 'enum', 'pi', 'TYPE_CHECKING', 'Iterable', 'Sequence'}]