import enum
import abc
from dataclasses import dataclass, field
from typing import *

import docker

from biosimulator_processes.data_model import _BaseClass
from test_suite.config import Config
from test_suite.utils import get_docker_image


class OutputMedium(str, enum.Enum):
    """ Output medium """
    console = 'console'
    gh_issue = 'gh_issue'


class TestCase(abc.ABC):
    """ A test case for validating a simulator

    Attributes:
        id (:obj:`str`): id
        name (:obj:`str`): name
        description (:obj:`str`): description
        output_medium (:obj:`OutputMedium`): medium the description should be formatted for
    """

    def __init__(self, id=None, name=None, description=None, output_medium=OutputMedium.console):
        """
        Args:
            id (:obj:`str`, optional): id
            name (:obj:`str`, optional): name
            description (:obj:`str`): description
            output_medium (:obj:`OutputMedium`, optional): medium the description should be formatted
        """
        self.id = id
        self.name = name
        self.description = description
        self.output_medium = output_medium

    @abc.abstractmethod
    def eval(self, specifications, working_dirname, synthetic_archives_dir=None, dry_run=False, cli=None):
        """ Evaluate a simulator's performance on a test case

        Args:
            specifications (:obj:`dict`): specifications of the simulator to validate
            working_dirname (:obj:`str`): directory for temporary files for evaluating test case
            synthetic_archives_dir (:obj:`str`, optional): Directory to save the synthetic COMBINE/OMEX archives
                generated by the test cases
            dry_run (:obj:`bool`, optional): if :obj:`True`, do not use the simulator to execute COMBINE/OMEX archives.
            cli (:obj:`str`, optional): command-line interface to use to execute the tests involving the simulation of COMBINE/OMEX
                archives rather than a Docker image

        Raises:
            :obj:`SkippedTestCaseException`: if the test case is not applicable to the simulator
            :obj:`Exception`: if the simulator did not pass the test case
        """
        pass  # pragma: no cover

    def get_simulator_docker_image(self, specifications, pull=None):
        """ Get the Docker image for a simulator, pulling if necessary

        Args:
            specifications (:obj:`dict`): specifications of the simulator to validate

        Returns:
            :obj:`docker.models.images.Image`: Docker image
        """
        docker_client = docker.from_env()
        image_url = specifications['image']['url']
        if pull is None:
            pull = Config().pull_docker_image
        return get_docker_image(docker_client, image_url, pull=pull)


@dataclass
class ModelSource:
    fp: str


@dataclass
class OMEXArchive(ModelSource):
    fp: str
    extraction_dir: str

    def __init__(self):
        self._extract_archive()

    def _extract_archive(self):
        # TODO: call biosimulator utils OMEX io methods here for reading
        pass


@dataclass
class ModelFile(ModelSource):
    fp: str
    lang_format: str  # ie: 'sbml'

    def __init__(self):
        self.lang_format = self.lang_format.lower()


class TestCompositionResults:
    def __init__(self, model_source: Union[ModelFile, OMEXArchive], expected_results_fp: str):
        self.evaluate(model_source, expected_results_fp)

    def evaluate(self, model_source: Union[ModelFile, OMEXArchive], expected_results_fp):
        source = self._extract_model_source(model_source)
        # Extract model source
        # load expected results
        # run composition
        # assert equal expected, composition

    def _extract_model_source(self, model_source: Union[ModelFile, OMEXArchive]):
        source_fp = model_source.fp
        # TODO: if isinstance(OMEXArchive): BIOSIMULATORS UTILS METHODS HERE!


def test_composition_results():
    pass


@dataclass
class ProjectsQuery(_BaseClass):
    project_ids: List[str]
    project_data: Dict


@dataclass
class ArchiveFiles(_BaseClass):
    run_id: str
    project_name: str
    files: List[Dict]


class RestService(abc.ABC):
    @classmethod
    @abc.abstractmethod
    async def _search_source(cls, query: str) -> ProjectsQuery:
        pass

    @classmethod
    @abc.abstractmethod
    async def fetch_files(cls, query: str) -> ProjectsQuery:
        pass

    @classmethod
    @abc.abstractmethod
    async def extract_data(cls, query: str, ) -> ProjectsQuery:
        pass
